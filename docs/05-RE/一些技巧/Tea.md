# Tea

## xxTea was the important
```c
// 函数参数说明：
// v: 指向待加密/解密数据数组的指针（每个元素为32位无符号整数）
// n: 数据数组长度。n>1表示加密，n<-1表示解密，绝对值代表实际长度
// key: 128位密钥，由4个32位无符号整数组成的数组

void btea(uint32_t* v, int n, uint32_t const key[4]) {
    uint32_t y, z, sum;
    unsigned p, rounds, e;
    
    // MX宏：核心的混淆运算，结合移位、异或、加法操作
    #define MX ( (z >> 5 ^ y << 2) + (y >> 3 ^ z << 4) ) ^ ( (sum ^ y) + (key[(p & 3) ^ e] ^ z) )
    
    //------------------ 加密部分（n > 1） ------------------//
    if (n > 1) {            
        rounds = 6 + 52 / n;  // 计算加密轮数，与数据长度相关
        sum = 0;
        z = v[n - 1];         // 初始化z为最后一个元素
        
        do {
            sum += DELTA;     // DELTA为固定常量（通常为0x9E3779B9）
            e = (sum >> 2) & 3; // 计算e，用于选择密钥索引
            
            // 正向遍历数组元素（从第0个到倒数第二个）
            for (p = 0; p < n - 1; p++) {
                y = v[p + 1]; // 取下一个元素
                z = v[p] += MX; // 更新当前元素并赋值给z
            }
            
            // 处理最后一个元素
            y = v[0];
            z = v[n - 1] += MX; 
        } while (--rounds);   // 循环执行rounds轮
    }
    
    //------------------ 解密部分（n < -1） ------------------//
    else if (n < -1) {      
        n = -n;               // 取绝对值得到实际长度
        rounds = 6 + 52 / n;  // 计算解密轮数（与加密轮数相同）
        sum = rounds * DELTA; // 初始sum为加密轮数的总DELTA累加值
        y = v[0];             // 初始化y为第一个元素
        
        do {
            e = (sum >> 2) & 3; // 计算e（与加密逻辑一致）
            
            // 反向遍历数组元素（从倒数第二个到第0个）
            for (p = n - 1; p > 0; p--) {
                z = v[p - 1]; // 取前一个元素
                y = v[p] -= MX; // 逆向恢复原始值
            }
            
            // 处理第一个元素
            z = v[n - 1];
            y = v[0] -= MX;
            sum -= DELTA;      // 逆向递减sum
        } while (--rounds);
    }
    
    #undef MX // 结束宏定义
}
```

### **TEA、XTEA与XXTEA算法对比分析**
---

#### **一、核心区别与特征总结**
以下是三种TEA系列算法的核心区别与特征对比：

| 特征                | TEA                         | XTEA                        | XXTEEA                      |
|---------------------|-----------------------------|-----------------------------|-----------------------------|
| **分组长度**        | 64位（2个32位字）           | 64位（2个32位字）           | 可变长度（最小64位）        |
| **密钥长度**        | 128位（4个32位子密钥）      | 128位（4个子密钥）          | 128位（4个子密钥）          |
| **核心混淆操作**    | 移位、加法、异或            | 改进的密钥混合与移位        | 非线性MX函数与多轮循环      |
| **Delta值**         | 固定0x9E3779B9（黄金分割数）| 同TEA                       | 同TEA                       |
| **轮数建议**        | 32轮（64轮理论存在）        | 64轮                        | 6+52/n轮（动态调整）        |
| **安全性**          | 较低（存在密钥相关攻击）     | 较高                        | 最高（当前TEA系列最安全）   |
| **适用场景**        | 嵌入式系统、低资源环境      | 通用加密                    | 需要高安全性的可变长度数据  |

---

#### **二、算法特性详解**

##### **1. TEA（Tiny Encryption Algorithm）**
• **特征**：
  • **Feistel结构**：基于64位分组的Feistel网络，左右半区交替处理。
  • **简单运算**：每轮包含左移4/5位、异或、加法操作，密钥直接参与混淆。
  • **Delta常量**：使用0x9E3779B9（黄金分割数相关值），确保每轮变化不同。
  • **密钥索引固定**：密钥轮询使用 `key[0]`、`key[1]` 等，易受侧信道攻击。

• **实例代码**（加密核心）：
  ```c
  for (i=0; i<32; i++) {
      sum += delta;
      l += ((r << 4) + k0) ^ (r + sum) ^ ((r >> 5) + k1);
      r += ((l << 4) + k2) ^ (l + sum) ^ ((l >> 5) + k3);
  }
  ```

##### **2. XTEA（Extended TEA）**
• **改进点**：
  • **动态密钥索引**：通过 `sum & 3` 和 `(sum >> 11) & 3` 动态选择密钥片段，增强抗差分攻击能力。
  • **密钥混合优化**：将密钥与sum结合，增加非线性。

• **特征**：
  • **轮数加倍**：建议64轮迭代，安全性高于TEA。
  • **密钥调度复杂**：`sum`的移位操作影响密钥选择，如 `key[(sum >> 11) & 3]`。

• **实例代码**（加密核心）：
  ```c
  for (i=0; i<num_rounds; i++) {
      v0 += (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3]);
      sum += delta;
      v1 += (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum >> 11) & 3]);
  }
  ```

##### **3. XXTEA（Corrected Block TEA）**
• **核心创新**：
  • **可变分组长度**：支持32位倍数的任意长度数据块（最小64位），适用性更广。
  • **MX混淆函数**：引入非线性运算 `MX = ((z>>5^y<<2) + (y>>3^z<<4)) ^ ((sum^y) + (key[(p&3)^e]^z))`，增强扩散性。
  • **多轮动态调整**：轮数由数据长度决定（`6 + 52/n`），适应不同分组大小。

• **特征**：
  • **非平衡Feistel结构**：处理长数据时逐字迭代，而非固定分组。
  • **抗选择明文攻击**：通过MX函数和动态密钥索引，避免TEA/XTEA的弱点。

• **实例代码**（加密核心）：
  ```c
  #define MX (((z>>5^y<<2)+(y>>3^z<<4))^((sum^y)+(key[(p&3)^e]^z)))
  while (q-- > 0) {
      sum += delta;
      e = (sum >> 2) & 3;
      for (p=0; p<n-1; p++) {
          y = v[p+1];
          z = v[p] += MX;
      }
      y = v[0];
      z = v[n-1] += MX;
  }
  ```

---