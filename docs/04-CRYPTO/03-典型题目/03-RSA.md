# RSA

（部分内容未分类完全，但基本可供阅读学习）

## 一些简单题目，来热热身

### 暴力破解n

1.使用 [在线工具](http://www.factordb.com/index.php)分解大质数

2.使用拓欧得到私钥d

   ```py
   def exgcd(a, b):
       if a == 0:
           return (b, 0, 1)
       else:
           gcd, x, y = ex(b % a, a)
           return (gcd, y - (b // a) * x, x)
   ```

3.计算flag bytes_to_long后的变量m

   ```py
   m = pow( c , d , n )
   ```

4.将整数m转化为字符串flag

   ```py
   m = 11604008605541818712966720001582142618375831382642459409129147724359509689501272522137152998605953387230762300554700585488547840790592562824581160993059033
   
   # 将整数转化为字节串
   flag = m.to_bytes((m.bit_length() + 7) // 8, 'big')
   
   # 输出字节串
   print(flag)
   ```

### Baby_RSA

因为 c = ( m ^ e ) % n

所以 c = ( m ^ e ) - k * n , 其中 k∈ N*

题目已知 c , e , n，求m；且 c 和 n 都是比较大的数，相对接近。

故可以枚举 k 的值，得到m的值

```
def solve( c , e , n ):
	k = 0
	while 1:
	    m = c + k * n
    	result , check = gmpy2.iroot(m, e)#求大整数x开n次根,result是返回的结果，check来判断是否正常返回
    	if check == 1:
            return check
        k += 1
m = solve( c , e , n )
print(long_to_bytes(m))
```

### Crt_RSA

n是两个大质数的乘积，因为数太大而导致解密缓慢

使用中国剩余定理可以帮助优化解密过程，将`模幂运算`分解为`对不同模数的模幂运算`，从而降低复杂度

```
e = 3
n = [n1,n2,n3]
c = [c1,c2,c3]
M, mod = crt(n, c)#M是CRT的结果，即合并多个RSA模数后得到的结果
m, check = gmpy2.iroot(M, e)
print(long_to_bytes(m))
```

### EmbryoRSA


1.计算n和φ(n)

   ```py
   n = p * q
   pn = (p-1) * (q-1)
   ```

2.使用扩展欧几里德算法找到d

   ```py
   def extended_gcd(a, b):
       if a == 0:
           return (b, 0, 1)
       else:
           gcd, x, y = extended_gcd(b % a, a)
           return (gcd, y - (b // a) * x, x)
   ```

3.得到私钥d

   ```py
   gcd, x, y = extended_gcd(e, phi_n)
   d = x % pn
   ```

4.得到flag

   ```
   m = pow( c , d , n )
   print( ans )
   flag = m.to_bytes((m.bit_length() + 7) // 8, 'big')
   print(flag)
   ```

RSA算法

生成秘钥

1.准备两个大质数p和q，将他们相乘得到n=pq

2.m=φ(n)=(p-1)(q-1)
3.找一个数e满足 gcd(m,e) = 1
4.ed mod m = 1（计算e在mod m下的逆元，记为d）
5.(n,e)为公钥，(n,d)为私钥

RSA秘钥生成代码

```python
p = 1000000007
q = 1000000009
e = 65521
n = p * q
m = (p-1) * (q-1)

def extended_gcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, x, y = extended_gcd(b % a, a)
        return (g, y - (b // a) * x, x)

def mod_inverse(e, m):
    g, x, y = extended_gcd(e, m)
    if g != 1:
        raise ValueError("The modular inverse does not exist")
    else:
        return x % m

d = mod_inverse(e, m)

print(f"公钥是({n},{e})")
print(f"私钥是({n},{d})")
```

RSA加密代码

```python
from Crypto.Util.number import bytes_to_long
#from Cryptodome.Util.number import bytes_to_long

flag = 'hello world'
flag_bytes = flag.encode('utf-8')  # 将字符串转换为字节数组
x = int.from_bytes(flag_bytes, byteorder='big')  # 使用big-endian字节序
n = 77
e = 17
y = pow(x, e, n)
print(y)
```

RSA解密代码

```python
y = 27
n = 77
d = 53
e = 17


# 解密密文
x = pow(y, d, n)

# 将解密后的整数转换为字节数组
flag_bytes = x.to_bytes((x.bit_length() + 7) // 8, byteorder='big')

# 将字节数组转换为字符串
flag = flag_bytes.decode('utf-8')

print("解密后的明文:", flag)
```

出现的问题

1.`pip install pycryptodome`报错

   `pip install --user pycryptodome`

   （ChatGPT解决）

---



## BUUCTF题库-RSA

此后这部分的题目，均来自BUUOJ

**在此篇wp中，统一规定，p和q表示两个大质数，他们的乘积记作n，n的欧拉函数φ(n)，公钥是(n,e)，私钥是(n,d)，明文是m，密文是c，满足**`c = m^e mod n` `m = c^d mod n`

### rsarsa 已知p q e c，求m

```
import gmpy2

p =  9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483
q =  11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407
e =  65537
c =  83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034

n = p * q
phi = (p-1) * (q-1)
d = gmpy2.invert(e,phi)
flag = pow( c , d , n )

print(flag)
```

flag{5577446633554466577768879988}

### RSA 已知p q e ，求d

```
import gmpy2

p=473398607161
q=4511491
e=17
phi = (p-1) * (q-1)

d = pow( e , phi-2 , phi )#m非质数，不能用费马小定理
print(d)#错误答案

d = gmpy2.invert( e , phi )
print(d)
```

flag{125631357777427553}

### RSA1 已知dp,dq

已知p q dp dq c

`dp = d % ( p - 1 ) , dq = d % ( q - 1 )`

`m1 = y^dp mod p , m2 = y^dq mod q `

`m = ( ( m2 - m1 ) * Inv( invert( q , p ) ) % p ) * q + m2`

**证明**

![](asserts\RSA1.jpg)

```
import gmpy2
from Crypto.Util.number import long_to_bytes

p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 
q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 
dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 
dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 
c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852

m1 = pow( c , dp , p )
m2 = pow( c , dq , q )
m = (((m2-m1) * gmpy2.invert( q , p ) ) % p ) * q + m2

print( long_to_bytes(m) )
```

flag{W31c0m3_70_Ch1n470wn}

### RSA2 dp泄露

已知e , n , c , dp

**证明**

![](asserts\RSA2.jpg)

```
import gmpy2
from Crypto.Util.number import long_to_bytes

e = 65537
n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113
dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657
c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751

for i in range( 1 , e ):
    if (dp*e-1)%i == 0:#判断p存在
        if n%(((dp*e-1)//i)+1) == 0 :#p可以把n整除
            p = (dp*e-1)//i+1
            q = n // p
            phi = (p-1) * (q-1)
            d = gmpy2.invert(e,phi)
            m = pow( c , d , n )

print( long_to_bytes(m) )
```

flag{wow_leaking_dp_breaks_rsa?_98924743502}

### RSA3 共膜攻击

已知n,c1,e1,c2,e2

**证明**

![](asserts\RSA3.jpg)

```
from gmpy2 import invert
from Crypto.Util.number import long_to_bytes
n=22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801
c1=22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361
e1=11187289
c2=18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397
e2=9647291

def exgcd( a , b ):
    if a == 0:
        return ( b , 0 , 1)
    else:
        g , y , x = exgcd( b%a , a )
        return ( g , x-(b//a)*y , y )
    
judge , s1 , s2 = exgcd( e1 , e2 )

if s1 < 0:
    s1 = - s1
    c1 = invert( c1 , n )
elif s2 < 0:
    s2 = - s2
    c2 = invert( c2 , n )
m = pow( c1 , s1 , n ) * pow( c2 , s2 , n ) % n

print( long_to_bytes(m) )
```

flag{49d91077a1abcb14f1a9d546c80be9ef}

### RSA

将pub.key用记事本打开得到公钥

使用公钥解析网站进行解析http://www.hiencode.com/pub_asys.html

![](asserts\image-20231102112308672.png)

n不是特别大，使用在线网站进行大质数分解http://www.factordb.com/

![](asserts\image-20231102112439195.png)

```
from Crypto.Util.number import long_to_bytes
from gmpy2 import invert
import rsa

p = 285960468890451637935629440372639283459
q = 304008741604601924494328155975272418463
e = 65537
n = p * q
phi = (p-1) * (q-1)
d = invert( e , phi )

key = rsa.PrivateKey(n,e,d,q,p)#私钥包含(n,e,d,p,q)
with open("C:\\Users\\coper\\Downloads\\0eaf8d6c-3fe5-4549-9e81-94ac42535e7b\\flag.enc","rb") as f:  #以二进制读模式，读取密文  
    f = f.read()
    print(rsa.decrypt(f,key))# f:公钥加密结果  key:私钥
```

### rsaroll

对一个文件中的多个密文进行解密

```
from Crypto.Util.number import long_to_bytes
from gmpy2 import invert

p = 18443
q = 49891
e = 19
n = p * q
phi = (p-1) * (q-1)
d = invert( e , phi )

flag = []
with open("C:\\Users\\coper\\Downloads\\02c01a13-3a86-47de-8648-f03328a5e5d8\\RsaRoll\\data.txt","r") as f:  #以二进制读模式，读取密文  
    for line in f.readlines():
        line = line.strip('\n')
        flag.append(chr(pow(int(line),d,n)))
for i in flag:
    print(i,end='')
```

flag{13212je2ue28fy71w8u87y31r78eu1e2}

### Dangerous RSA

低加密指数攻击。条件：e非常小（python太tm神奇了）

`c = m^e % n`

1.`m^e < n`时，`c = m^e`
2.`m^e > n`时，`c = m^e - k*n`，即 `m^e = k*n+C`。对k进行爆破，只要k满足 k*n+C能开e次方根就可以

gmpy2库中iroot(a,b) 表示对a开b次方根，返回第一个数表示答案，第二个数表示是不是整数

运行时发现n的数值中多一个'L'，不是16进制，删掉即可获得flag

```
from Crypto.Util.number import long_to_bytes
import gmpy2

n = 0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793
c = 0x10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365
e = 0x3
k = 0

while 1:
    flag = gmpy2.iroot( c+k*n , e )
    if flag[1] == True:
        print( long_to_bytes(flag[0]) )
        break
    k = k + 1
```

flag{25df8caf006ee5db94d48144c33b2c3b}

### rsa2

只有公钥，都很大

RSAwienerHacker离线工具进行破解

![](asserts\image-20231107090130789.png)

hashlib在python3上运行不了，得用python2

![](asserts\image-20231107091049789.png)

flag{47bf28da384590448e0b0d23909a25a4}

## 一些比赛中的 RSA 相关题目

### [GUET-CTF2019]BabyRSA

p + q = x , (p+1)*(q+1) = y

y=(p+1)\*(q+1)=p\*q+p+q+1=n+x+1

n=y-x-1

![](asserts\image-20231111213325734.png)

flag{cc7490e-78ab-11e9-b422-8ba97e5da1fd}

### [BUUCTF·AFCTF2018]可怜的RSA

public.key:

```
-----BEGIN PUBLIC KEY-----
MIIBJDANBgkqhkiG9w0BAQEFAAOCAREAMIIBDAKCAQMlsYv184kJfRcjeGa7Uc/4
3pIkU3SevEA7CZXJfA44bUbBYcrf93xphg2uR5HCFM+Eh6qqnybpIKl3g0kGA4rv
tcMIJ9/PP8npdpVE+U4Hzf4IcgOaOmJiEWZ4smH7LWudMlOekqFTs2dWKbqzlC59
NeMPfu9avxxQ15fQzIjhvcz9GhLqb373XDcn298ueA80KK6Pek+3qJ8YSjZQMrFT
+EJehFdQ6yt6vALcFc4CB1B6qVCGO7hICngCjdYpeZRNbGM/r6ED5Nsozof1oMbt
Si8mZEJ/Vlx3gathkUVtlxx/+jlScjdM7AFV5fkRidt0LkwosDoPoRz/sDFz0qTM
5q5TAgMBAAE=
-----END PUBLIC KEY-----
```

flag.enc:

```
GVd1d3viIXFfcHapEYuo5fAvIiUS83adrtMW/MgPwxVBSl46joFCQ1plcnlDGfL19K/3PvChV6n5QGohzfVyz2Z5GdTlaknxvHDUGf5HCukokyPwK/1EYU7NzrhGE7J5jPdi0Aj7xi/Odxy0hGMgpaBLd/nL3N8O6i9pc4Gg3O8soOlciBG/6/xdfN3SzSStMYIN8nfZZMSq3xDDvz4YB7TcTBh4ik4wYhuC77gmT+HWOv5gLTNQ3EkZs5N3EAopy11zHNYU80yv1jtFGcluNPyXYttU5qU33jcp0Wuznac+t+AZHeSQy5vk8DyWorSGMiS+J4KNqSVlDs12EqXEqqJ0uA==
```

---

读取public.key

```
from Crypto.PublicKey import RSA
f = open('public.key', 'rb').read()
pub = RSA.importKey(f)
n = pub.n
e = pub.e
print(n, '\n', e)
```

得到的n进行分解

![](asserts\image-20240107221027950.png)

编写脚本即可解密

```
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from base64 import b64decode
import libnum
import gmpy2

e = 65537
p = 3133337
q = 25478326064937419292200172136399497719081842914528228316455906211693118321971399936004729134841162974144246271486439695786036588117424611881955950996219646807378822278285638261582099108339438949573034101215141156156408742843820048066830863814362379885720395082318462850002901605689761876319151147352730090957556940842144299887394678743607766937828094478336401159449035878306853716216548374273462386508307367713112073004011383418967894930554067582453248981022011922883374442736848045920676341361871231787163441467533076890081721882179369168787287724769642665399992556052144845878600126283968890273067575342061776244939
n = p * q
phi = (p-1)*(q-1)
d = int(gmpy2.invert( e , phi ))#这一步一定要转成int，不然mpz会报错

key_info = RSA.construct((n, e, d, p, q))
key = RSA.importKey(key_info.exportKey())
key = PKCS1_OAEP.new(key)
f = open('flag.enc', 'r').read()
c = b64decode(f)
flag = key.decrypt(c)
print(flag)
```

flag:`flag{R54_|5_$0_B0rin9}`

### [CTFshow元旦水友赛]NOeasyRSA

```
from Crypto.Util.number import long_to_bytes
from Crypto.Util.strxor import strxor
from random import randint
from flag import FLAG
 
def f(x, n):  
    return (pow(u,n,p)*x + v*(1-pow(u,n,p))*pow(1-u, -1, p)) % p  
 
p = 97201997431130462639713476119411091922677381239967611061717766639853376871260165905989218335681560177626304205941143288128749532327607316527719299945637260643711897738116821179208534292854942631428531228316344113303402450588666012800739695018334321748049518585617428717505851025279186520225325765864212731597
u = 14011530787746260724685809284106528245188320623672333581950055679051366424425259006994945665868546765648275822501035229606171697373122374288934559593175958252416643298136731105775907857798815936190074350794406666922357841091849449562922724459876362600203284195621546769313749721476449207319566681142955460891977927184371401451946649848065952527323468939007868874410618846898618148752279316070498097254384228565132693552949206926391461108714034141321700284318834819732949544823937032615318011463993204345644038210938407875147446570896826729265366024224612406740371824999201173579640264979086368843819069035017648357042
v = 16560637729264127314502582188855146263038095275553321912067588804088156431664370603746929023264744622682435376065011098909463163865218610904571775751705336266271206718700427773757241393847274601309127403955317959981271158685681135990095066557078560050980575698278958401980987514566688310172721963092100285717921465575782434632190913355536291988686994429739581469633462010143996998589435537178075521590880467628369030177392034117774853431604525531066071844562073814187461299329339694285509725214674761990940902460186665127466202741989052293452290042871514149972640901432877318075354158973805495004367245286709191395753
w = 30714296289538837760400431621661767909419746909959905820574067592409316977551664652203146506867115455464665524418603262821119202980897986798059489126166547078057148348119365709992892615014626003313040730934533283339617856938614948620116906770806796378275546490794161777851252745862081462799572448648587153412425374338967601487603800379070501278705056791472269999767679535887678042527423534392867454254712641029797659150392148648565421400107500607994226410206105774620083214215531253544274444448346065590895353139670885420838370607181375842930315910289979440845957719622069769102831263579510660283634808483329218819353
a = randint(0, 2**2048)
b = randint(0, 2**2048)
A = f(w, a)
B = f(w, b)
key = long_to_bytes(f(B, a))[:len(FLAG)]
enc = strxor(FLAG, key)
print(f"{A = }")
print(f"{B = }")
print(f"{enc = }")

"""
A = 19000912802080599027672447674783518419279033741329820736608320648294849832904652704615322546923683308427498322653162857743332527479657555691849627174691056234736228204031597391109766621450008024310365149769851160904834246087493085291270515883474521052340305802461028930107070785434600793548735004323108063823
B = 73344156869667785951629011239443984128961974188783039136848369309843181351498207375582387449307849089511875560536212143659712959631858144127598424003355287131145957594729789310869405545587664999655457134475561514111282513273352679348722584469527242626837672035004800949907749224093056447758969518003237425788
enc = b'\xfd\xc1\xb7\x9d"$\xc2\xb0\xb5\xee\xf89\xa4V\x8e\x17\x01K9\xbc.\x92=\x85\x80\xd4\x03\xefAl"\xbd\x8b\xcdL\xb5\xa3!'
"""
```

---

只要思想不滑坡，这题就是推推式子（呜呜呜我自己做的时候把抄错好几个数死活调不出来呜呜...）

```
import gmpy2
from Crypto.Util.number import long_to_bytes
from Crypto.Util.strxor import strxor

p = 97201997431130462639713476119411091922677381239967611061717766639853376871260165905989218335681560177626304205941143288128749532327607316527719299945637260643711897738116821179208534292854942631428531228316344113303402450588666012800739695018334321748049518585617428717505851025279186520225325765864212731597
u = 14011530787746260724685809284106528245188320623672333581950055679051366424425259006994945665868546765648275822501035229606171697373122374288934559593175958252416643298136731105775907857798815936190074350794406666922357841091849449562922724459876362600203284195621546769313749721476449207319566681142955460891977927184371401451946649848065952527323468939007868874410618846898618148752279316070498097254384228565132693552949206926391461108714034141321700284318834819732949544823937032615318011463993204345644038210938407875147446570896826729265366024224612406740371824999201173579640264979086368843819069035017648357042
v = 16560637729264127314502582188855146263038095275553321912067588804088156431664370603746929023264744622682435376065011098909463163865218610904571775751705336266271206718700427773757241393847274601309127403955317959981271158685681135990095066557078560050980575698278958401980987514566688310172721963092100285717921465575782434632190913355536291988686994429739581469633462010143996998589435537178075521590880467628369030177392034117774853431604525531066071844562073814187461299329339694285509725214674761990940902460186665127466202741989052293452290042871514149972640901432877318075354158973805495004367245286709191395753
w = 30714296289538837760400431621661767909419746909959905820574067592409316977551664652203146506867115455464665524418603262821119202980897986798059489126166547078057148348119365709992892615014626003313040730934533283339617856938614948620116906770806796378275546490794161777851252745862081462799572448648587153412425374338967601487603800379070501278705056791472269999767679535887678042527423534392867454254712641029797659150392148648565421400107500607994226410206105774620083214215531253544274444448346065590895353139670885420838370607181375842930315910289979440845957719622069769102831263579510660283634808483329218819353
A = 19000912802080599027672447674783518419279033741329820736608320648294849832904652704615322546923683308427498322653162857743332527479657555691849627174691056234736228204031597391109766621450008024310365149769851160904834246087493085291270515883474521052340305802461028930107070785434600793548735004323108063823
B = 73344156869667785951629011239443984128961974188783039136848369309843181351498207375582387449307849089511875560536212143659712959631858144127598424003355287131145957594729789310869405545587664999655457134475561514111282513273352679348722584469527242626837672035004800949907749224093056447758969518003237425788
enc = b'\xfd\xc1\xb7\x9d"$\xc2\xb0\xb5\xee\xf89\xa4V\x8e\x17\x01K9\xbc.\x92=\x85\x80\xd4\x03\xefAl"\xbd\x8b\xcdL\xb5\xa3!'

ua = ((u-1)*A+v)*gmpy2.invert((u-1)*w+v,p) % p
key = (ua * B + v * ( 1 - ua ) * gmpy2.invert( 1-u , p ) ) % p
flag = strxor( enc , long_to_bytes(key)[:len(enc)] )
print( flag )
```

flag:`ctfshow{This_Is_Really_Not_So_Smooth!}`

问题：为什么取负运算在模域上对值没有改变

```
ua = ((u-1)*A+v)*gmpy2.invert((u-1)*w+v,p) % p
ub = ((A*((1-u))-v) * gmpy2.invert(w*(1-u)-v,p)) % p
assert ua == ub
```

通过yafu计算，p是质数

![](asserts\image-20240109134635922.png)

回答：因为有逆元，是分式；分子分母同时取负，值不变

### [CTFshow元旦水友赛]NOeasyRSA

```
import random
from hashlib import md5
from Crypto.Util.number import *
from flag import flag

def get_state(kbits, k):
    seed = [(random.getrandbits(kbits) >> k) & 0xfffffff for i in range(624)]
    state = (3, tuple(seed + [0]), None)
    return state


def give_gift(kbits, num):
    gift = [random.getrandbits(kbits) for i in range(num)]
    e = random.getrandbits(7)
    l_num = num - e
    s_box = list(range(num))
    random.shuffle(s_box)
    l_gift = [gift[i] for i in s_box[:l_num]]
    return (l_gift, s_box[:l_num], e)


def enc_flag(state, e):
    key = bytes_to_long(md5(long_to_bytes(state[1][e])).digest())
    enc = bytes_to_long(flag) ^ key
    return enc


kbits, k, num = random.randrange(64), random.randrange(16), random.randrange(400, 600)
state = get_state(kbits, k)
random.setstate(state)
gift = give_gift(kbits, num)
enc = enc_flag(state, gift[2])
print(gift, enc)

# ([91463260584, 97520150804, 134987178347, 134745660347, 23369346769, 88869916197, 67723104206, 132211190015, 74383600340, 57357411421, 80301226226, 2847043233, 46071508714, 76391425800, 71113777427, 12603028605, 127607785895, 82661956584, 48539405830, 131191473154, 137430688091, 48026249914, 105523652421, 58217141456, 135651011411, 37099885733, 101903983367, 117525416468, 49720139903, 123719748136, 58611168240, 68135859850, 6355615539, 23769720298, 7999623487, 19601432037, 49460687576, 34510812373, 97988805553, 120381187017, 37643325426, 79314538948, 128727827227, 41938289773, 74120986880, 29052999070, 21215042789, 76176648906, 82899209179, 90338690991, 102277220210, 109016314367, 2419923303, 75246152672, 109203867772, 87030346778, 119151949871, 134868756437, 124854798665, 122116306769, 31536426951, 82104297926, 118556737102, 78417017414, 81807286830, 24688295471, 126360674284, 8870569872, 105339369180, 61910863416, 56597235604, 50122937080, 135836683348, 75685244539, 112566491901, 86217144353, 110999080631, 91114786530, 94967775022, 52680440255, 76947914257, 133052296759, 22589975272, 104632324223, 47428022416, 106941367714, 119250845700, 80196618477, 92917756830, 52764061858, 82855761133, 26800124167, 129317288037, 44051967549, 70500283649, 165355182, 78293334339, 45001066520, 84638985033, 32566871344, 38421055041, 56145488218, 83396525174, 116762960131, 58381974438, 132249926372, 36091120717, 35213963219, 88756092150, 45288405267, 27461079382, 19589246113, 28308681656, 47161727545, 69898448282, 22959597168, 132569999975, 100557577568, 127037292334, 29708117311, 33229333831, 29311547868, 135347707719, 85435007922, 54540391811, 109544478077, 66841548339, 47159376439, 42574542524, 62176229940, 3138675000, 21267865120, 22618290315, 126018690563, 21590061225, 9799239940, 10617934652, 40956988582, 131053131140, 90043238501, 81283244185, 109338223936, 68311960398, 25088200986, 28895564195, 17646619057, 82775422880, 81522377214, 28334564831, 100791800926, 85872403124, 127915503356, 72496838376, 109007653011, 96263138881, 69693106974, 4718076407, 68334177311, 31708464646, 96111162918, 48965277868, 54931198292, 105535767797, 105680940066, 109968562576, 23573023928, 48569942163, 106967716286, 94835446653, 92803971955, 53791818332, 14453746086, 132101017989, 26361874022, 32122658200, 51724426274, 114997634813, 75838224666, 89848273104, 73619960674, 97795812498, 132466249292, 25997032367, 40732063573, 59142286405, 68524304985, 49545031400, 28044368864, 95700359624, 108201671504, 127043767055, 9384509797, 120972803416, 41782179648, 76653307257, 44056421640, 101631026937, 99078185959, 54885001820, 69316726710, 19710227322, 86035277688, 42289562955, 98051921147, 79098792488, 106490144808, 13834874, 69114014086, 4418515159, 109316722991, 92603496375, 68830244931, 111949257703, 102637560761, 5012149380, 43811237017, 4526712578, 102995188930, 9165821006, 63456393327, 68912422322, 104913358841, 108860651772, 52967416635, 84227988465, 101715630295, 26297443306, 110653579906, 91487440397, 116959430145, 83499469513, 48913630229, 76988993305, 41832173701, 13694488408, 135450931748, 39634435716, 41679152695, 126540504548, 91399825525, 99004649347, 19517357430, 8279948639, 133596449559, 1449103211, 50732184406, 52247676129, 74928416312, 64326525401, 124673786795, 92042480385, 24404916254, 99622146133, 51463314254, 36722967192, 4007778602, 39109534005, 120478575332, 99886542155, 5756463131, 91679854224, 3608646835, 35655876863, 121959477025, 20408412916, 36341277711, 43627610089, 24855949002, 128669830633, 70347508117, 9425085453, 2022963949, 5053312318, 63243834495, 21497715007, 5936366400, 44266914863, 119468825913, 91726986385, 126494307832, 93847533617, 22070910941, 20204251399, 42254244260, 60489335607, 40705184865, 80919639775, 73360223499, 132743946450, 88897376509, 103144368275, 9982808097, 131532980487, 91081435155, 78915930938, 72790758029, 120696671493, 78255313725, 13309583510, 23841020581, 116634908326, 73400462338, 57323203784, 46210923108, 41134724194, 43089395737, 118503520944, 111039189867, 99418263301, 59298127775, 45252940179, 40345195432, 16841439060, 100422187771, 65791698364, 61167532292, 30338914082, 14930863404, 4703203112, 124912009656, 9195518396, 18552364400, 7303227315, 105753747788, 3079040268, 116480022128, 1215344111, 9934249637, 76178148585, 20033461169, 87344780021, 72391242953, 129540048833, 15495213032, 49963621916, 84362224351, 97100635498, 105086571577, 51150506310, 118045067326, 65966867679, 7925108854, 131280748402, 66481282233, 107509392827, 78521145687, 35456851157, 97461157961, 30244093674, 24123083085, 27909475052, 69646113342, 131930611276, 97792139629, 135917828529, 32305782568, 59325645293, 84962280113, 74529748221, 22659244720, 54776660364, 66934871192, 14824496938, 37231294479, 102244198902, 31674646475, 128196911226, 90158594889, 121714346066, 64647669235, 105263204191, 127988380741, 130175056631, 114272442969, 135960937840, 62465712860, 32333037569, 137012433094, 92929672123, 86030288893, 73602847949, 58136148471, 118893337093, 97692245318, 99539974338, 116231441994, 32445182154, 115683286754, 114711297102, 102210385893, 7687212992, 73626254322, 242951419, 5952493527, 96817591608, 45197171621, 122928115217, 106192593180, 99889552302, 125596158762, 136959359712, 67291405558, 71974425715, 115789979144, 59321975202, 84748820897, 133266408556, 6800817333, 110678933813, 96832595879, 97681824039, 89341148630, 84626208563, 58523733456, 93000780873, 68444996084, 775177345, 17204124036, 129474447019, 73589942581, 65415043899, 131703332659, 101783987222, 61388598262, 103435807803, 104030629529, 19123072760, 63612557945, 38245223725, 54345357864, 62016904380, 34602169486, 51229280420, 66624757580, 68760378559, 131556923700, 21935621011, 36349470821, 10120892182, 25883848878, 71735922493, 62883391871, 90647098, 41388569318, 52175456448, 71822304690, 19251125978, 91308465291, 50110754397, 91050175581, 83697004380, 6165622900, 129188497722, 71424103672, 57569171583, 13220579058, 118266862549, 21791521844, 70064705221, 83120075317, 83316886784, 111745960042, 26241940218, 32402511427, 118604113535, 98847819357, 117058412964, 57680263912, 83166477192], [508, 300, 327, 517, 431, 195, 41, 162, 110, 358, 433, 105, 40, 256, 172, 50, 474, 55, 67, 284, 215, 118, 513, 98, 120, 26, 155, 298, 4, 233, 243, 267, 428, 478, 494, 226, 146, 488, 20, 113, 143, 136, 49, 236, 128, 346, 501, 264, 498, 0, 413, 30, 410, 99, 1, 220, 443, 369, 290, 374, 119, 511, 483, 199, 248, 351, 388, 335, 131, 79, 496, 245, 414, 244, 158, 451, 255, 412, 47, 473, 254, 95, 299, 462, 169, 519, 493, 12, 257, 385, 432, 417, 59, 93, 455, 324, 52, 90, 407, 288, 112, 34, 528, 29, 192, 101, 419, 203, 123, 176, 177, 167, 204, 445, 416, 485, 196, 302, 424, 425, 6, 418, 258, 17, 370, 262, 227, 326, 387, 294, 295, 174, 25, 188, 81, 408, 469, 11, 472, 80, 400, 84, 382, 448, 201, 344, 7, 502, 163, 312, 484, 349, 239, 108, 411, 315, 303, 377, 36, 383, 78, 339, 491, 271, 216, 187, 322, 140, 405, 296, 402, 516, 450, 22, 482, 361, 371, 249, 453, 64, 152, 72, 194, 66, 345, 492, 447, 58, 486, 357, 149, 200, 83, 212, 219, 504, 333, 23, 439, 376, 457, 332, 153, 348, 210, 237, 173, 359, 129, 179, 426, 71, 19, 321, 338, 444, 139, 307, 515, 88, 266, 475, 182, 323, 336, 354, 272, 384, 330, 2, 211, 446, 238, 397, 230, 278, 141, 506, 181, 70, 316, 314, 459, 235, 121, 286, 76, 518, 280, 43, 111, 62, 487, 429, 524, 364, 86, 228, 353, 275, 104, 441, 268, 13, 500, 68, 87, 109, 403, 520, 231, 391, 42, 51, 328, 253, 436, 60, 497, 313, 481, 522, 53, 61, 420, 225, 189, 325, 183, 56, 100, 229, 27, 39, 3, 184, 291, 415, 454, 75, 28, 107, 347, 421, 166, 224, 279, 16, 342, 206, 207, 171, 368, 198, 456, 464, 406, 365, 151, 320, 161, 9, 89, 479, 142, 259, 401, 232, 523, 449, 150, 218, 15, 97, 287, 133, 458, 221, 63, 185, 350, 74, 135, 404, 466, 214, 116, 507, 355, 213, 178, 318, 423, 126, 395, 465, 440, 452, 157, 366, 190, 343, 467, 247, 509, 91, 205, 114, 193, 409, 375, 269, 373, 389, 148, 69, 396, 398, 317, 145, 122, 147, 512, 32, 130, 386, 94, 435, 310, 57, 422, 308, 305, 217, 8, 154, 156, 309, 223, 44, 24, 82, 160, 392, 477, 356, 134, 54, 138, 378, 331, 379, 250, 96, 489, 306, 399, 46, 18, 283, 470, 21, 360, 209, 168, 495, 180, 514, 191, 270, 510, 381, 186, 442, 31, 390, 5, 85, 92, 363, 33, 127, 197, 285, 380, 265, 48, 352, 505, 208, 438, 329, 468, 282, 45, 159, 301, 362, 341, 65, 263, 393, 222, 521, 175, 293, 37, 490, 35], 60) 912396759652812740801869061695733452669218533249083289698313292427681899514848561025221753354562922565560034
```

---

首先读代码

```
#生成三个随机数，数据范围很小，属于可爆破范围
kbits, k, num = random.randrange(64), random.randrange(16), random.randrange(400, 600)

#生成624个不大于28bits的随机数，打包进state里
seed = [(random.getrandbits(kbits) >> k) & 0xfffffff for i in range(624)]
state = (3, tuple(seed + [0]), None)

#设置随机数内部状态
random.setstate(state)

#生成一个随机长度，随机大小的gift
gift = [random.getrandbits(kbits) for i in range(num)]
#生成一个e，不大于7bits
e = random.getrandbits(7)
l_num = num - e
#将小于num的数构成一个列表，并打乱顺序
s_box = list(range(num))
random.shuffle(s_box)
#把又是一个随机的数打包进gift
l_gift = [gift[i] for i in s_box[:l_num]]
gift = (l_gift, s_box[:l_num], e)

#用一个随机的不大于28bits的数生成密钥
key = bytes_to_long(md5(long_to_bytes(state[1][gift[2]])).digest())
enc = bytes_to_long(flag) ^ key

print(gift, enc)
```

读了半天，才发现前面的全是随机数的随机数，只有key的生成这一句有用，直接爆破一个大小不大于28bits的数即可

给了一堆gift，对于得到flag没有什么作用

```
from hashlib import md5
from Crypto.Util.number import *

enc = 912396759652812740801869061695733452669218533249083289698313292427681899514848561025221753354562922565560034

for i in range( int(0xfffffff)+1 ):
    key = bytes_to_long(md5(long_to_bytes(i)).digest())
    flag = long_to_bytes(key^enc)
    if "\\" in str(flag):
        continue
    else:
        print( i , flag )
```

由于数据量过大，直接查关键字`ctfshow`出现的数据过多，而table我又不会用，故可以直接查找不存在十六进制无法翻译成字符的，可以得到flag

![](asserts\image-20240111155315912.png)

找出一个没有奇怪字符、大括号在最后面的即为flag

观赏了学长的代码，巧妙地运用了table，不用手动选择flag了（不过时间复杂度一样，都是线性的）

还有tqdm，有了它，就可以看到进度条了（不过不知道为什么我的电脑上用tqdm总是卡崩掉）

```
from tqdm import tqdm
from Crypto.Util.number import *
from hashlib import md5
import string

def dec(num):
    num = int(num)
    key = bytes_to_long(md5(long_to_bytes(num)).digest())
    m = enc ^ key
    m = long_to_bytes(m)
    try:
        flag = m.decode()
        if all(f in table for f in flag):
            print(flag)
            print(f"num = {num}")
    except:
        return

table = string.ascii_letters + '0123456789_-{}'

enc = 912396759652812740801869061695733452669218533249083289698313292427681899514848561025221753354562922565560034

for i in tqdm(range(0xfffffff+1)):
    dec(i)
```

flag:`ctfshow{F2AD971D-66C2-2D1D-69D6-CE7DE2A49B35}`

### [CTFshow元旦水友赛]哪位师傅知道这个是什么密码啊？

![](asserts\image-20240113000226608.png)

```
import os
from Crypto.Util.number import *

F = lambda x: x * F(x-1) if x > 0 else 1
G = lambda x, y: F(x) // (F(y) * F(x-y))

def get_keys(n: int):
    p = getPrime(-11+45-14)
    print('Please wait...')
    s_list, t_list, u_list = [], [], []
    for i in range(n):
        print(f'Progress: {i+1} / {n}')
        while True:
            t, s = sorted(getPrime(101) for _ in 'NB')
            u = (G(s, t) % p) & 0xFF
            if (u != 0):
                s_list.append(s)
                t_list.append(t)
                u_list.append(u)
                break
    return (s_list, t_list, p), u_list 

FLAG = os.getenv('FLAG', 'ctfshow{never_gonna_give_you_flag}')
print( FLAG )
pubkey, privkey = get_keys(len(FLAG))
print( pubkey, privkey )
ciphertext = bytes(x ^ k for x, k in zip(FLAG.encode(), privkey))
print(f'{pubkey = }')
print(f'{ciphertext.hex() = }')
```

---

F是阶乘，G是组合数的计算过程

[卢卡斯定理（OI-wiki）](https://oi-wiki.org/math/number-theory/lucas/)

![](asserts\image-20240113001008310.png)

```
from Crypto.Util.number import *
from Crypto.Util.number import long_to_bytes
import gmpy2

pubkey = ([2244095333388513367565281205621, 2260083173627571225575272017643, 2232571619487249695276209431911, 1366892418499855676258266570183, 2453504829447242891596294199551, 1749886540398964782388250510153, 2400368813718195311072803190537, 2412199908745985611198006411271, 2136151769918417200012573467547, 2188326070621506831342201179489, 2490975888687886171609455918979, 2520972296586880497850481220517, 2505441601685892494158922143537, 2223691958889488499464345149631, 2419970291634469073461115862923, 1913431629076248544274472723887, 1516525599480634064271895075589, 1748534379194448515689583072903, 2254654291529452465905257115983, 2036853065650744279222351374007, 1942468846337869648732525843309, 2201940065043223214975123483717, 2420554654468916631069996311243, 1578933527329599278882739520739, 2185608727926152268827042689247, 2138991356060432718559850740837, 1993202582269353654593882658857, 1851957155599032687165578632711, 1675430935325353825921279241939, 1539732791462031791764734543397, 1452444069464058198195009866663, 1853102085689472930613090539653, 2422886163436887722911429199407, 2478151413643348620173265601687, 2081728653302754258684980999897, 1869475969698886966223998022243, 2514233209214621717689871577799, 1565641057982670427875243690007, 2470941525500295562801927618117, 1957593611795889447618691712899, 2380166810104233903974756831281, 2310844976072657607087683813659, 2138906021714896472557340201269, 2133283066222174180401711231107, 2307615052065649723749209072291], [1950345581706607236958613312239, 1513963021166149007673751427809, 2209549849936350178706915353711, 1282304331826641551367349314389, 1285901314103578143578261497933, 1732171004069526252052648123229, 1885905081824428587397820753449, 2156360504061214962564655540577, 2114387282072764844800146882587, 1713540614501303042289450513031, 1718611954585760080721231776949, 2395901674478208382890220594709, 1953786497785706690568567652501, 1434952765892339228311211916623, 1434633435633106679937918543013, 1272002714370288579710832521801, 1345903574845925448968871221921, 1599178580175752823633130749379, 2050880877544639868041580689117, 1268507788047119658102789429151, 1550740527937339681775447782103, 2026060127920636700353677740333, 2320801697813895006451348616587, 1489309276821468831592096904009, 1343134452830065788367338410993, 1825449623429915829785766822487, 1385771207130987392492516965847, 1681955135857458220104835916897, 1608580883454393934111909197727, 1417761672076182691155757676783, 1339284864034936616590020649969, 1741000210994367137067807994129, 1416704333290652593089933548759, 1833600804996263316791298228287, 1740533709307600192323357511421, 1516475145585568797228308698679, 2284536672877756851447268908997, 1271126734775727764840925368047, 1674941925848400149104085993761, 1826602689042665336846528498857, 1987838509832756026588063009051, 1689378070597281801400506154393, 1490675164221922597195547712943, 1601946500767026172849726987951, 2081320371490185790723799153587], 560113)
ciphertext = int('8b232301d0d8b5a681c1c982b04763b8765a8bbfb2bdf7332d0990f2a04b487dff3ffb0c6f1b1faefcd3037cf7',16)
( s_list , t_list , p ) = pubkey

def C( n , m , p ):
    up , down = 1 , 1
    for i in range( n - m + 1 , n + 1 ):
        up = up * i % p
    for i in range( 1 , m + 1 ):
        down = down * i % p
    return up * gmpy2.invert( down , p ) % p

def lucas( n , m , p ):
    if m == 0:
        return 1
    return C( n % p , m % p , p ) * lucas( n // p , m // p , p ) % p


u_list = []
for s,t in zip(s_list,t_list):
    u_list.append( lucas(s,t,p) & 0xFF )

flag = bytes(x ^ k for x, k in zip(long_to_bytes(ciphertext), u_list))
print(flag)
```

flag:`ctfshow{a786316f-b09b-4b83-b52c-8e20ef3c23d7}`（动态）

![](asserts\image-20240113002329237.png)

首次完整复盘了一场比赛的所有密码学题。

后续还需要完善的，有`sign_rand`的正解部分和`哪位师傅知道这个是什么？`的卢卡斯定理的推到和拓展卢卡斯定理

### [BUUCTF·GWCTF2019]BabyRSA

```
import hashlib
import sympy
from Crypto.Util.number import *

flag = 'GWHT{******}'
secret = '******'

assert(len(flag) == 38)

half = len(flag) / 2

flag1 = flag[:half]
flag2 = flag[half:]

secret_num = getPrime(1024) * bytes_to_long(secret)

p = sympy.nextprime(secret_num)
q = sympy.nextprime(p)

N = p * q

e = 0x10001

F1 = bytes_to_long(flag1)
F2 = bytes_to_long(flag2)

c1 = F1 + F2
c2 = pow(F1, 3) + pow(F2, 3)
assert(c2 < N)

m1 = pow(c1, e, N)
m2 = pow(c2, e, N)

output = open('secret', 'w')
output.write('N=' + str(N) + '\n')
output.write('m1=' + str(m1) + '\n')
output.write('m2=' + str(m2) + '\n')
output.close()
"""
N=636585149594574746909030160182690866222909256464847291783000651837227921337237899651287943597773270944384034858925295744880727101606841413640006527614873110651410155893776548737823152943797884729130149758279127430044739254000426610922834573094957082589539445610828279428814524313491262061930512829074466232633130599104490893572093943832740301809630847541592548921200288222432789208650949937638303429456468889100192613859073752923812454212239908948930178355331390933536771065791817643978763045030833712326162883810638120029378337092938662174119747687899484603628344079493556601422498405360731958162719296160584042671057160241284852522913676264596201906163
m1=90009974341452243216986938028371257528604943208941176518717463554774967878152694586469377765296113165659498726012712288670458884373971419842750929287658640266219686646956929872115782173093979742958745121671928568709468526098715927189829600497283118051641107305128852697032053368115181216069626606165503465125725204875578701237789292966211824002761481815276666236869005129138862782476859103086726091860497614883282949955023222414333243193268564781621699870412557822404381213804026685831221430728290755597819259339616650158674713248841654338515199405532003173732520457813901170264713085107077001478083341339002069870585378257051150217511755761491021553239
m2=487443985757405173426628188375657117604235507936967522993257972108872283698305238454465723214226871414276788912058186197039821242912736742824080627680971802511206914394672159240206910735850651999316100014691067295708138639363203596244693995562780286637116394738250774129759021080197323724805414668042318806010652814405078769738548913675466181551005527065309515364950610137206393257148357659666687091662749848560225453826362271704292692847596339533229088038820532086109421158575841077601268713175097874083536249006018948789413238783922845633494023608865256071962856581229890043896939025613600564283391329331452199062858930374565991634191495137939574539546
"""
```

---

p和q是相邻的质数，一眼yafu

![](asserts\image-20240113134805626.png)

成功分解

后面需要解方程 $c_1=f_1+f_2 \ , \ c_2 = f_1^3 + f_2^3$

使用python的solve函数即可求解

```
from Crypto.Util.number import long_to_bytes
from sympy import *
from sympy.abc import x,y
import gmpy2

m1=90009974341452243216986938028371257528604943208941176518717463554774967878152694586469377765296113165659498726012712288670458884373971419842750929287658640266219686646956929872115782173093979742958745121671928568709468526098715927189829600497283118051641107305128852697032053368115181216069626606165503465125725204875578701237789292966211824002761481815276666236869005129138862782476859103086726091860497614883282949955023222414333243193268564781621699870412557822404381213804026685831221430728290755597819259339616650158674713248841654338515199405532003173732520457813901170264713085107077001478083341339002069870585378257051150217511755761491021553239
m2=487443985757405173426628188375657117604235507936967522993257972108872283698305238454465723214226871414276788912058186197039821242912736742824080627680971802511206914394672159240206910735850651999316100014691067295708138639363203596244693995562780286637116394738250774129759021080197323724805414668042318806010652814405078769738548913675466181551005527065309515364950610137206393257148357659666687091662749848560225453826362271704292692847596339533229088038820532086109421158575841077601268713175097874083536249006018948789413238783922845633494023608865256071962856581229890043896939025613600564283391329331452199062858930374565991634191495137939574539546
p = 797862863902421984951231350430312260517773269684958456342860983236184129602390919026048496119757187702076499551310794177917920137646835888862706126924088411570997141257159563952725882214181185531209186972351469946269508511312863779123205322378452194261217016552527754513215520329499967108196968833163329724620251096080377748737
q = 797862863902421984951231350430312260517773269684958456342860983236184129602390919026048496119757187702076499551310794177917920137646835888862706126924088411570997141257159563952725882214181185531209186972351469946269508511312863779123205322378452194261217016552527754513215520329499967108196968833163329724620251096080377747699
n = p * q ; phi = (p-1) * (q-1) ; e = 0x10001 ; d = gmpy2.invert( e , phi )
c1 = pow( m1 , d , n ) ; c2 = pow( m2 , d , n )

res = solve( [ x+y-c1 , pow(x,3)+pow(y,3)-c2 ] , [ x , y ] )
print( long_to_bytes( res[0][1] ) + long_to_bytes( res[0][0] ) )
```

flag:`flag{f709e0e2cfe7e530ca8972959a1033b2}`

### [NSSCTF Round#16 Basic]pr

```
from Crypto.Util.number import *
import random

flag=plaintext = 'NSSCTF{****************}'
charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
padding_length = 100 - len(plaintext)

for _ in range(padding_length):
    plaintext += random.choice(charset)

public_exponent = 31413537523
message = bytes_to_long(plaintext.encode())
assert message > (1 << 512)
assert message < (1 << 1024)

prime_p = getPrime(512)
prime_q = getPrime(512)
prime_r = getPrime(512)
n1 = prime_p * prime_q
n2 = prime_q * prime_r
ciphertext1 = pow(message, public_exponent, n1)
ciphertext2 = pow(message, public_exponent, n2)
print('c1=', ciphertext1)
print('c2=', ciphertext2)
print('p=', prime_p)
print('r=', prime_r)
print( plaintext )
print( prime_q )


'''
c1= 36918910341116680090654563538246204134840776220077189276689868322808977412566781872132517635399441578464309667998925236488280867210758507758915311644529399878185776345227817559234605958783077866016808605942558810445187434690812992072238407431218047312484354859724174751718700409405142819140636116559320641695
c2= 15601788304485903964195122196382181273808496834343051747331984997977255326224514191280515875796224074672957848566506948553165091090701291545031857563686815297483181025074113978465751897596411324331847008870832527695258040104858667684793196948970048750296571273364559767074262996595282324974180754813257013752
p= 12101696894052331138951718202838643670037274599483776996203693662637821825873973767235442427190607145999472731101517998719984942030184683388441121181962123
r= 10199001137987151966640837133782537428248507382360655526592866939552984259171772190788036403425837649697437126360866173688083643144865107648483668545682383
'''
```

---

赛时想到了crt，但是犯了低级错误，导致没有在赛时出flag---><img src="C:\Users\coper\AppData\Roaming\Typora\typora-user-images\image-20240113181842330.png" alt="image-20240113181842330" style="zoom: 33%;" />

也是因为对于模运算的性质掌握不够熟练，放弃crt之后一直想求q，因而一直没有出来

```
from Crypto.Util.number import *
import gmpy2

c1= 36918910341116680090654563538246204134840776220077189276689868322808977412566781872132517635399441578464309667998925236488280867210758507758915311644529399878185776345227817559234605958783077866016808605942558810445187434690812992072238407431218047312484354859724174751718700409405142819140636116559320641695
c2= 15601788304485903964195122196382181273808496834343051747331984997977255326224514191280515875796224074672957848566506948553165091090701291545031857563686815297483181025074113978465751897596411324331847008870832527695258040104858667684793196948970048750296571273364559767074262996595282324974180754813257013752
p= 12101696894052331138951718202838643670037274599483776996203693662637821825873973767235442427190607145999472731101517998719984942030184683388441121181962123
r= 10199001137987151966640837133782537428248507382360655526592866939552984259171772190788036403425837649697437126360866173688083643144865107648483668545682383
e = 31413537523

def crtt( c , p ):
    M = 1
    for i in p:
        M = M * i
    m = []
    for i in range(len(p)):
        m.append(M // p[i])
    x = 0
    for i in range(len(c)):
        x = x + c[i]*m[i]*gmpy2.invert(m[i],p[i])
    return x % M

c = crtt( [ c1 , c2 ] , [ p , r ] )
phi = ( p-1 ) * (r-1)
d = gmpy2.invert( e , phi )

print( long_to_bytes(pow( c , d , p*r )) )
```

flag:`NSSCTF{yUanshEnx1ncHun2o23!}`

### [isctf2023]七七的欧拉

使用大质数分解在线网站，得到 n=p^8

已知n=p^x时，φ(n)=p^x-p^(x-1)（欧拉函数的第二种快速计算方式）

则phi=p^8-p^7

```
import gmpy2
from Crypto.Util.number import long_to_bytes
e=
n=
c=
p=
phi = p**8-p**7
d = gmpy2.invert( e , phi )
print( long_to_bytes( pow(c,d,n) ) )
```

ISCTF{3237saq-21se82-3s74f8-8h84ps7-9qw45v7-6bs531-s26h23-c7iu01}

### [isctf2023]signin

Schmidt-Samoa密码系统

密钥生成：选取两个大质数，计算N=p^2\*q；计算d=invert(N,φ(p\*q))

加密：c=m^N mod N

解密：m=c^d mod p*q

```
import gmpy2
 
c = 
N = 
d = 

pq = gmpy2.gcd(pow(2,d*N,N) - 2,N)
m = pow(c,d,pq)

print( long_to_bytes(m) )
```

ISCTF{aeb8be10-ff19-42cf-8cfd-2ce71ac418e8}

### [isctf2023]Easy_AES

```
import gmpy2
from Crypto.Util.number import long_to_bytes
from Crypto.Util.number import *
from Crypto.Cipher import AES
import os

flag = b"ISCTF{"
key = b"1513562561656285"

hint = int(b'0x47405a4847405a48470000021a0f2870',16)

print( hint )

for i in range( 49 , 50 ):
    t = b"\t\t\t\t\t\t\t\t\t" + flag + chr(i).encode()
    print( chr(i) )
    #print( bytes_to_long(t) ^ hint )
    key = long_to_bytes( bytes_to_long(t) ^ hint )
    print( key )
"""
flag = b"ISCTF{asnxjbnmkishubxhxbasxmscmskldjvl}"
key = b"NISANISANISANISA"
enc = b'bsF\xb6m\xcf\x94\x9fg1\xfaxG\xd4\xa3\x04\xfb\x9c\xac\xed\xbe\xc4\xc0\xb5\x899|u\xbf9e\xe0\xa6\xdb5\xa8x\x84\x95(\xc6\x18\xfe\x07\x88\x02\xe1v'


for i in range( 10 ):
    #iv = b'\xac\xec\xec\x1d\xd4@\xdd\xf6\xcf\xda\xbcb\xdeg\x06\x9d'
    iv = os.urandom(16)
    aes = AES.new(key,AES.MODE_CBC,iv)
    flag = aes.decrypt( enc )
    #print( iv )
    print( flag )
    #print( flag[:5] )

flag{b106cea3fb848e7bea310c9851f15c1}
"""
```

flag{1b106cea3fb848e7bea310c9851f15c1}

### [NSSCTF Round#16 Basic]break

```
Bc8tSTrvGJm2oYuCzIz+Yg4nwwKBgQDiYUawe5Y+rPbFhVOMVB8ZByfMa4LjeSDd
Z23jEGvylBHSeyvFCQq3ISUE40k1D2XmmeaZML3a1nUn6ORIWGaG2phcwrWLkR6n
ubVmb1QJSzgzmFHGnL56KHByZxD9q6DPB+o6gGWt8/6ddBl2NIZU/1btdPQgojfA
XXJFzR92RQKBgQC7qlB0U7m2U4FdG9eelSd+WSKNUVllZAuHji7jgh7Ox6La9xN5
miGZ1yvP44yX218OJ9Zi08o6vIrM6Eil45KzTtGm4iuIn8CMpox+5eUtoxyvxa9r
s2Wu+IRZN9zCME+p+qI8/TG27dIyDzsdgNqcUo8ESls7uW5/FEA7bYTCiQKBgQC7
1KybeB+kZ0zlfIdi8tVOpeI+uaHDbdh3+/5wHUsD3hmfg7VAag0q/2RA1vkB/oG1
QVLVHl0Yu0I/1/u5jyeakrtClAegAsvlrK+3i321rGS4YpTPb3SX1P/f3GZ7o7Ds
touA+NHk8IL9T7xkmJYw5h/RLG32ucH6aU6MXfLR5QKBgD/skfdFxGWxhHk6U1mS
27IM9jJNg9xLz5nxzkqPPhLn+rdgIIuTuQtv++eEjEP++7ZV10rg5yKVJd/bxy8H
2IN7aQo7kZWulHTQDZMFwgOhn0u6glJi+qC8bWzYDFOQSFrY9XQ3vwKMspqm+697
xM+dMUW0LML6oUE9ZjEiAY/5
-----END PRIVATE KEY-----
```

```
6081370370545409218106271903400346695565292992689150366474451604281551878507114813906275593034729563149286993189430514737137534129570304832172520820901940874698337733991868650159489601159238582002010625666203730677577976307606665760650563172302688129824842780090723167480409842707790983962415315804311334507726664838464859751689906850572044873633896253285381878416855505301919877714965930289139921111644393144686543207867970807469735534838601255712764863973853116693691206791007433101433703535127367245739289103650669095061417223994665200039533840922696282929063608853551346533188464573323230476645532002621795338655
```

---

对于一个pem私钥文件，包含：

```
RSAPrivateKey ::= SEQUENCE {
version Version,
modulus INTEGER, -- n
publicExponent INTEGER, -- e
privateExponent INTEGER, -- d
prime1 INTEGER, -- p
prime2 INTEGER, -- q
exponent1 INTEGER, -- d mod (p-1)
exponent2 INTEGER, -- d mod (q-1)
coefficient INTEGER, -- (inverse of q) mod p
otherPrimeInfos OtherPrimeInfos OPTIONAL
}
```

编写脚本利用`02`分割

```
from base64 import *

a ='''Bc8tSTrvGJm2oYuCzIz+Yg4nwwKBgQDiYUawe5Y+rPbFhVOMVB8ZByfMa4LjeSDd
Z23jEGvylBHSeyvFCQq3ISUE40k1D2XmmeaZML3a1nUn6ORIWGaG2phcwrWLkR6n
ubVmb1QJSzgzmFHGnL56KHByZxD9q6DPB+o6gGWt8/6ddBl2NIZU/1btdPQgojfA
XXJFzR92RQKBgQC7qlB0U7m2U4FdG9eelSd+WSKNUVllZAuHji7jgh7Ox6La9xN5
miGZ1yvP44yX218OJ9Zi08o6vIrM6Eil45KzTtGm4iuIn8CMpox+5eUtoxyvxa9r
s2Wu+IRZN9zCME+p+qI8/TG27dIyDzsdgNqcUo8ESls7uW5/FEA7bYTCiQKBgQC7
1KybeB+kZ0zlfIdi8tVOpeI+uaHDbdh3+/5wHUsD3hmfg7VAag0q/2RA1vkB/oG1
QVLVHl0Yu0I/1/u5jyeakrtClAegAsvlrK+3i321rGS4YpTPb3SX1P/f3GZ7o7Ds
touA+NHk8IL9T7xkmJYw5h/RLG32ucH6aU6MXfLR5QKBgD/skfdFxGWxhHk6U1mS
27IM9jJNg9xLz5nxzkqPPhLn+rdgIIuTuQtv++eEjEP++7ZV10rg5yKVJd/bxy8H
2IN7aQo7kZWulHTQDZMFwgOhn0u6glJi+qC8bWzYDFOQSFrY9XQ3vwKMspqm+697
xM+dMUW0LML6oUE9ZjEiAY/5'''

txt = ""
for i in a.split():
    txt = txt + str(b64decode(i).hex())

txt = txt.split("02")

for i in txt:
    print( i )
```

得到运行结果：

```
05cf2d493aef1899b6a18b82cc8cfe620e27c3
818100e26146b07b963eacf6c585538c541f190727cc6b82e37920dd676de3106bf29411d27b2bc5090ab7212504e349350f65e699e69930bddad67527e8e448586686da985cc2b58b911ea7b9b5666f54094b38339851c69cbe7a2870726710fdaba0cf07ea3a8065adf3fe9d741976348654ff56ed74f420a237c05d7245cd1f7645
818100bbaa507453b9b653815d1bd79e95277e59228d515965640b878e2ee3821ecec7a2daf713799a2199d72bcfe38c97db5f0e27d662d3ca3abc8acce848a5e392b34ed1a6e22b889fc08ca68c7ee5e52da31cafc5af6bb365aef8845937dcc2304fa9faa23cfd31b6edd2320f3b1d80da9c528f044a5b3bb96e7f14403b6d84c289
818100bbd4ac9b781fa4674ce57c8762f2d54ea5e23eb9a1c36dd877fbfe701d4b03de199f83b5406a0d2aff6440d6f901fe81b54152d51e5d18bb423fd7fbb98f279a92bb429407a0
cbe5acafb78b7db5ac64b86294cf6f7497d4ffdfdc667ba3b0ecb68b80f8d1e4f082fd4fbc64989630e61fd12c6df6b9c1fa694e8c5df2d1e5
81803fec91f745c465b184793a535992dbb20cf6324d83dc4bcf99f1ce4a8f3e12e7fab76
08b93b90b6ffbe7848c43fefbb655d74ae0e7229525dfdbc72f07d8837b690a3b9195ae9474d00d9305c203a19f4bba825262faa0bc6d6cd80c5390485ad8f57437bf
8cb29aa6fbaf7bc4cf9d3145b42cc2faa1413d663122018ff9
```

获取到最后几组数据

```
from Crypto.Util.number import *
import gmpy2

q = 0x00e26146b07b963eacf6c585538c541f190727cc6b82e37920dd676de3106bf29411d27b2bc5090ab7212504e349350f65e699e69930bddad67527e8e448586686da985cc2b58b911ea7b9b5666f54094b38339851c69cbe7a2870726710fdaba0cf07ea3a8065adf3fe9d741976348654ff56ed74f420a237c05d7245cd1f7645
c = 6081370370545409218106271903400346695565292992689150366474451604281551878507114813906275593034729563149286993189430514737137534129570304832172520820901940874698337733991868650159489601159238582002010625666203730677577976307606665760650563172302688129824842780090723167480409842707790983962415315804311334507726664838464859751689906850572044873633896253285381878416855505301919877714965930289139921111644393144686543207867970807469735534838601255712764863973853116693691206791007433101433703535127367245739289103650669095061417223994665200039533840922696282929063608853551346533188464573323230476645532002621795338655
e = 0x10001
m = pow(c, gmpy2.invert(e, q-1),q)
print( long_to_bytes(m) )
```

flag:`NSSCTF{oi!_you_find___what_i_Wa1t_talK_y0n!!!}`

相关考点：openssl rsa

### [BUUCTF·NCTF2019]babyRSA

```
from Crypto.Util.number import *
from flag import flag

def nextPrime(n):
    n += 2 if n & 1 else 1
    while not isPrime(n):
        n += 2
    return n

p = getPrime(1024)
q = nextPrime(p)
n = p * q
e = 0x10001
d = inverse(e, (p-1) * (q-1))
c = pow(bytes_to_long(flag.encode()), e, n)

# d = 19275778946037899718035455438175509175723911466127462154506916564101519923603308900331427601983476886255849200332374081996442976307058597390881168155862238533018621944733299208108185814179466844504468163200369996564265921022888670062554504758512453217434777820468049494313818291727050400752551716550403647148197148884408264686846693842118387217753516963449753809860354047619256787869400297858568139700396567519469825398575103885487624463424429913017729585620877168171603444111464692841379661112075123399343270610272287865200880398193573260848268633461983435015031227070217852728240847398084414687146397303110709214913
# c = 5382723168073828110696168558294206681757991149022777821127563301413483223874527233300721180839298617076705685041174247415826157096583055069337393987892262764211225227035880754417457056723909135525244957935906902665679777101130111392780237502928656225705262431431953003520093932924375902111280077255205118217436744112064069429678632923259898627997145803892753989255615273140300021040654505901442787810653626524305706316663169341797205752938755590056568986738227803487467274114398257187962140796551136220532809687606867385639367743705527511680719955380746377631156468689844150878381460560990755652899449340045313521804
```

---

我们已知 $e*d \equiv 1\ mod\ phi$

恒等式化等式得到：$e*d=1+k*phi$

```
d = 19275778946037899718035455438175509175723911466127462154506916564101519923603308900331427601983476886255849200332374081996442976307058597390881168155862238533018621944733299208108185814179466844504468163200369996564265921022888670062554504758512453217434777820468049494313818291727050400752551716550403647148197148884408264686846693842118387217753516963449753809860354047619256787869400297858568139700396567519469825398575103885487624463424429913017729585620877168171603444111464692841379661112075123399343270610272287865200880398193573260848268633461983435015031227070217852728240847398084414687146397303110709214913
e = 0x10001
ed = str(bin( e * d - 1 ))
print( ed , len(ed)-2 )#把前缀'0b'去掉
```

$e*d$ 长度为 $2064$，而 $phi$ 的长度应当为 $2048$，故 $k$ 的范围是 $2^{15}$~$2^{16}$，穷举即可

```
from Crypto.Util.number import *
import sympy.crypto
import gmpy2

d = 19275778946037899718035455438175509175723911466127462154506916564101519923603308900331427601983476886255849200332374081996442976307058597390881168155862238533018621944733299208108185814179466844504468163200369996564265921022888670062554504758512453217434777820468049494313818291727050400752551716550403647148197148884408264686846693842118387217753516963449753809860354047619256787869400297858568139700396567519469825398575103885487624463424429913017729585620877168171603444111464692841379661112075123399343270610272287865200880398193573260848268633461983435015031227070217852728240847398084414687146397303110709214913
c = 5382723168073828110696168558294206681757991149022777821127563301413483223874527233300721180839298617076705685041174247415826157096583055069337393987892262764211225227035880754417457056723909135525244957935906902665679777101130111392780237502928656225705262431431953003520093932924375902111280077255205118217436744112064069429678632923259898627997145803892753989255615273140300021040654505901442787810653626524305706316663169341797205752938755590056568986738227803487467274114398257187962140796551136220532809687606867385639367743705527511680719955380746377631156468689844150878381460560990755652899449340045313521804
e = 0x10001
p = q = 0

for k in range( 2**15 , 2**16 ):
    if ( e * d - 1 ) % k == 0:
        p = sympy.prevprime( gmpy2.iroot( ( e * d - 1 ) // k , 2 )[0] ) ;
        q = sympy.nextprime( p )
        if (e*d-1)==(p-1)*(q-1)*k:
            break
n = p * q
print( long_to_bytes( pow( c , d , n ) ) )
```

flag:`flag{70u2_nn47h_14_v3ry_gOO0000000d}`

### [BUUCTF·AFCTF2018]你能看出这是什么加密么

```
p=0x928fb6aa9d813b6c3270131818a7c54edb18e3806942b88670106c1821e0326364194a8c49392849432b37632f0abe3f3c52e909b939c91c50e41a7b8cd00c67d6743b4f

q=0xec301417ccdffa679a8dcc4027dd0d75baf9d441625ed8930472165717f4732884c33f25d4ee6a6c9ae6c44aedad039b0b72cf42cab7f80d32b74061

e=0x10001

c=0x70c9133e1647e95c3cb99bd998a9028b5bf492929725a9e8e6d2e277fa0f37205580b196e5f121a2e83bc80a8204c99f5036a07c8cf6f96c420369b4161d2654a7eccbdaf583204b645e137b3bd15c5ce865298416fd5831cba0d947113ed5be5426b708b89451934d11f9aed9085b48b729449e461ff0863552149b965e22b6   
```

---

普通的rsa，直接解即可

python每日小寄巧：别直接复制（尤其是c），原文有毒

```
import gmpy2
from Crypto.Util.number import *

p=0x928fb6aa9d813b6c3270131818a7c54edb18e3806942b88670106c1821e0326364194a8c49392849432b37632f0abe3f3c52e909b939c91c50e41a7b8cd00c67d6743b4f
q=0xec301417ccdffa679a8dcc4027dd0d75baf9d441625ed8930472165717f4732884c33f25d4ee6a6c9ae6c44aedad039b0b72cf42cab7f80d32b74061
e=0x10001
c=0x70c9133e1647e95c3cb99bd998a9028b5bf492929725a9e8e6d2e277fa0f37205580b196e5f121a2e83bc80a8204c99f5036a07c8cf6f96c420369b4161d2654a7eccbdaf583204b645e137b3bd15c5ce865298416fd5831cba0d947113ed5be5426b708b89451934d11f9aed9085b48b729449e461ff0863552149b965e22b6

n = p * q ; phi = (p-1)*(q-1)
d = gmpy2.invert( e , phi )
print( long_to_bytes( pow(c,d,n) ) )
```

flag:`flag{R54_|5_$0_$imp13}`

### [BUUCTF·RoarCTF2019]RSA

```
A=(((y%x)**5)%(x%y))**2019+y**316+(y+1)/x
p=next_prime(z*x*y)
q=next_prime(z)
A =  2683349182678714524247469512793476009861014781004924905484127480308161377768192868061561886577048646432382128960881487463427414176114486885830693959404989743229103516924432512724195654425703453612710310587164417035878308390676612592848750287387318129424195208623440294647817367740878211949147526287091298307480502897462279102572556822231669438279317474828479089719046386411971105448723910594710418093977044179949800373224354729179833393219827789389078869290217569511230868967647963089430594258815146362187250855166897553056073744582946148472068334167445499314471518357535261186318756327890016183228412253724
n =  117930806043507374325982291823027285148807239117987369609583515353889814856088099671454394340816761242974462268435911765045576377767711593100416932019831889059333166946263184861287975722954992219766493089630810876984781113645362450398009234556085330943125568377741065242183073882558834603430862598066786475299918395341014877416901185392905676043795425126968745185649565106322336954427505104906770493155723995382318346714944184577894150229037758434597242564815299174950147754426950251419204917376517360505024549691723683358170823416757973059354784142601436519500811159036795034676360028928301979780528294114933347127
c =  41971850275428383625653350824107291609587853887037624239544762751558838294718672159979929266922528917912189124713273673948051464226519605803745171340724343705832198554680196798623263806617998072496026019940476324971696928551159371970207365741517064295956376809297272541800647747885170905737868568000101029143923792003486793278197051326716680212726111099439262589341050943913401067673851885114314709706016622157285023272496793595281054074260451116213815934843317894898883215362289599366101018081513215120728297131352439066930452281829446586562062242527329672575620261776042653626411730955819001674118193293313612128
```

---

通过yafu不能分解，利用factor可以分解得到p和q

可能会出现分母为0的情况，故需要判断

```
from Crypto.Util.number import *
from gmpy2 import *

p = 842868045681390934539739959201847552284980179958879667933078453950968566151662147267006293571765463137270594151138695778986165111380428806545593588078365331313084230014618714412959584843421586674162688321942889369912392031882620994944241987153078156389470370195514285850736541078623854327959382156753458569
q = 139916095583110895133596833227506693679306709873174024876891023355860781981175916446323044732913066880786918629089023499311703408489151181886568535621008644997971982182426706592551291084007983387911006261442519635405457077292515085160744169867410973960652081452455371451222265819051559818441257438021073941183
n = p * q
phi = (p-1)*(q-1)
c = 41971850275428383625653350824107291609587853887037624239544762751558838294718672159979929266922528917912189124713273673948051464226519605803745171340724343705832198554680196798623263806617998072496026019940476324971696928551159371970207365741517064295956376809297272541800647747885170905737868568000101029143923792003486793278197051326716680212726111099439262589341050943913401067673851885114314709706016622157285023272496793595281054074260451116213815934843317894898883215362289599366101018081513215120728297131352439066930452281829446586562062242527329672575620261776042653626411730955819001674118193293313612128

for e in range( 2 , 100000 ):
    try:
        d = invert( e , phi )
        m = str(long_to_bytes( pow(c,d,n) ))
        if "CTF" in m or "flag" in m:
            print( m )
    except ZeroDivisionError:
        continue
```

flag:`flag{wm-l1l1ll1l1l1l111ll}`

### [BUUCTF·RoarCTF2019]babyRSA

```
import sympy
import random

def myGetPrime():
    A= getPrime(513)
    print(A)
    B=A-random.randint(1e3,1e5)
    print(B)
    return sympy.nextPrime((B!)%A)
p=myGetPrime()
#A1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407
#B1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596

q=myGetPrime()
#A2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927
#B2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026

r=myGetPrime()

n=p*q*r
#n=85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733
c=pow(flag,e,n)
#e=0x1001
#c=75700883021669577739329316795450706204502635802310731477156998834710820770245219468703245302009998932067080383977560299708060476222089630209972629755965140317526034680452483360917378812244365884527186056341888615564335560765053550155758362271622330017433403027261127561225585912484777829588501213961110690451987625502701331485141639684356427316905122995759825241133872734362716041819819948645662803292418802204430874521342108413623635150475963121220095236776428
#so,what is the flag?
```

---

威尔逊定理：$(p-1)! \equiv -1 \ mod \ p$ 其中p是质数

要求 $Ans = B!\ \% \ A$ ，只需求 $(A-1)! \ \% \ A$ 和 $B! * (A-1)!^{-1}$

其中 $(A-1)! \equiv -1 \ mod \ A$ 和 $(B! * (A-1)!^{-1})^{-1}=\prod_{b+1}^{A-1}$

故 $Ans= -(\prod_{b+1}^{A-1})^{-1}$

```
from Crypto.Util.number import *
from gmpy2 import *
from sympy import *

A1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407
B1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596
A2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927
B2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026
n=85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733
e=0x1001
c=75700883021669577739329316795450706204502635802310731477156998834710820770245219468703245302009998932067080383977560299708060476222089630209972629755965140317526034680452483360917378812244365884527186056341888615564335560765053550155758362271622330017433403027261127561225585912484777829588501213961110690451987625502701331485141639684356427316905122995759825241133872734362716041819819948645662803292418802204430874521342108413623635150475963121220095236776428
    
p = 1 ; q = 1
for i in range( B1+1 , A1 ):
    p = p * i % A1
p = nextprime(-invert( p , A1 ) % A1)
for i in range( B2+1 , A2 ):
    q = q * i % A2
q = nextprime(-invert( q , A2 ) % A2)

r = n // ( p * q )
d = gmpy2.invert(e,(p-1)*(q-1)*(r-1))
print( long_to_bytes( pow( c , d , n ) ) ) 
```

flag:`flag{wm-CongrAtu1ation4-1t4-ju4t-A-bAby-R4A}`

### [BUUCTF·BJDCTF2020]rsa_output

```
{21058339337354287847534107544613605305015441090508924094198816691219103399526800112802416383088995253908857460266726925615826895303377801614829364034624475195859997943146305588315939130777450485196290766249612340054354622516207681542973756257677388091926549655162490873849955783768663029138647079874278240867932127196686258800146911620730706734103611833179733264096475286491988063990431085380499075005629807702406676707841324660971173253100956362528346684752959937473852630145893796056675793646430793578265418255919376323796044588559726703858429311784705245069845938316802681575653653770883615525735690306674635167111,2767}

{21058339337354287847534107544613605305015441090508924094198816691219103399526800112802416383088995253908857460266726925615826895303377801614829364034624475195859997943146305588315939130777450485196290766249612340054354622516207681542973756257677388091926549655162490873849955783768663029138647079874278240867932127196686258800146911620730706734103611833179733264096475286491988063990431085380499075005629807702406676707841324660971173253100956362528346684752959937473852630145893796056675793646430793578265418255919376323796044588559726703858429311784705245069845938316802681575653653770883615525735690306674635167111,3659}

message1=20152490165522401747723193966902181151098731763998057421967155300933719378216342043730801302534978403741086887969040721959533190058342762057359432663717825826365444996915469039056428416166173920958243044831404924113442512617599426876141184212121677500371236937127571802891321706587610393639446868836987170301813018218408886968263882123084155607494076330256934285171370758586535415136162861138898728910585138378884530819857478609791126971308624318454905992919405355751492789110009313138417265126117273710813843923143381276204802515910527468883224274829962479636527422350190210717694762908096944600267033351813929448599

message2=11298697323140988812057735324285908480504721454145796535014418738959035245600679947297874517818928181509081545027056523790022598233918011261011973196386395689371526774785582326121959186195586069851592467637819366624044133661016373360885158956955263645614345881350494012328275215821306955212788282617812686548883151066866149060363482958708364726982908798340182288702101023393839781427386537230459436512613047311585875068008210818996941460156589314135010438362447522428206884944952639826677247819066812706835773107059567082822312300721049827013660418610265189288840247186598145741724084351633508492707755206886202876227
```

知道n和两组e两组c，故是共膜攻击

```
import gmpy2
from Crypto.Util.number import long_to_bytes

n = 21058339337354287847534107544613605305015441090508924094198816691219103399526800112802416383088995253908857460266726925615826895303377801614829364034624475195859997943146305588315939130777450485196290766249612340054354622516207681542973756257677388091926549655162490873849955783768663029138647079874278240867932127196686258800146911620730706734103611833179733264096475286491988063990431085380499075005629807702406676707841324660971173253100956362528346684752959937473852630145893796056675793646430793578265418255919376323796044588559726703858429311784705245069845938316802681575653653770883615525735690306674635167111
e1 = 2767
e2 = 3659

c1 = 20152490165522401747723193966902181151098731763998057421967155300933719378216342043730801302534978403741086887969040721959533190058342762057359432663717825826365444996915469039056428416166173920958243044831404924113442512617599426876141184212121677500371236937127571802891321706587610393639446868836987170301813018218408886968263882123084155607494076330256934285171370758586535415136162861138898728910585138378884530819857478609791126971308624318454905992919405355751492789110009313138417265126117273710813843923143381276204802515910527468883224274829962479636527422350190210717694762908096944600267033351813929448599
c2 = 11298697323140988812057735324285908480504721454145796535014418738959035245600679947297874517818928181509081545027056523790022598233918011261011973196386395689371526774785582326121959186195586069851592467637819366624044133661016373360885158956955263645614345881350494012328275215821306955212788282617812686548883151066866149060363482958708364726982908798340182288702101023393839781427386537230459436512613047311585875068008210818996941460156589314135010438362447522428206884944952639826677247819066812706835773107059567082822312300721049827013660418610265189288840247186598145741724084351633508492707755206886202876227

def exgcd( a , b ):
    if a == 0:
        return ( b , 0 , 1 )
    else:
        g , y , x = exgcd( b % a , a )
        return ( g , x - ( b // a ) * y , y )

s = exgcd( e1 , e2 )
s1 = -s[1] ; s2 = s[2]
c1 = gmpy2.invert( c1 , n )
m = ( pow( c1 , s1 ) * pow( c2 , s2 ) ) % n
print( long_to_bytes( m ) )
```

flag:`flag{r3a_C0mmoN_moD@_4ttack}`

### [BUUCTF]SameMod

```
{6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249,773}
{6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249,839}

message1=3453520592723443935451151545245025864232388871721682326408915024349804062041976702364728660682912396903968193981131553111537349
message2=5672818026816293344070119332536629619457163570036305296869053532293105379690793386019065754465292867769521736414170803238309535
```

很好的共膜攻击，使我的python翻转

使用传统的`long_to_bytes`解出得到的是乱码

好多1哇·······那个97好眼熟——实际上正解是通过ascll码进行转化得到flag

```
import gmpy2
from Crypto.Util.number import long_to_bytes

n = 6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249
e1 = 773
e2 = 839
c1 = 3453520592723443935451151545245025864232388871721682326408915024349804062041976702364728660682912396903968193981131553111537349
c2 = 5672818026816293344070119332536629619457163570036305296869053532293105379690793386019065754465292867769521736414170803238309535

def exgcd( a , b ):
    if a == 0:
        return ( b , 0 , 1 )
    else:
        g , y , x = exgcd( b % a , a )
        return ( g , x - ( b // a ) * y , y )

s = exgcd( e1 , e2 )
s1 = -s[1] ; s2 = s[2]
c1 = gmpy2.invert( c1 , n )
m = str(( pow( c1 , s1 ) * pow( c2 , s2 ) ) % n)
cnt = 0
num = ""
top = 3
for i in m:
    num = num + i
    cnt += 1
    if num[0] == "1":
        top = 3
    else:
        top = 2
    if cnt == top:
        cnt = 0
        print( chr(int(num)) , end="" )
        num = ""
```

flag:`flag{whenwethinkitispossible}`

### [BUUCTF·BJDCTF2020]easyrsa

```
from Crypto.Util.number import getPrime,bytes_to_long
from sympy import Derivative
from fractions import Fraction
from secret import flag

p=getPrime(1024)
q=getPrime(1024)
e=65537
n=p*q
z=Fraction(1,Derivative(arctan(p),p))-Fraction(1,Derivative(arth(q),q))
m=bytes_to_long(flag)
c=pow(m,e,n)
print(c,z,n)
'''
output:
7922547866857761459807491502654216283012776177789511549350672958101810281348402284098310147796549430689253803510994877420135537268549410652654479620858691324110367182025648788407041599943091386227543182157746202947099572389676084392706406084307657000104665696654409155006313203957292885743791715198781974205578654792123191584957665293208390453748369182333152809882312453359706147808198922916762773721726681588977103877454119043744889164529383188077499194932909643918696646876907327364751380953182517883134591810800848971719184808713694342985458103006676013451912221080252735948993692674899399826084848622145815461035
32115748677623209667471622872185275070257924766015020072805267359839059393284316595882933372289732127274076434587519333300142473010344694803885168557548801202495933226215437763329280242113556524498457559562872900811602056944423967403777623306961880757613246328729616643032628964072931272085866928045973799374711846825157781056965164178505232524245809179235607571567174228822561697888645968559343608375331988097157145264357626738141646556353500994924115875748198318036296898604097000938272195903056733565880150540275369239637793975923329598716003350308259321436752579291000355560431542229699759955141152914708362494482
15310745161336895413406690009324766200789179248896951942047235448901612351128459309145825547569298479821101249094161867207686537607047447968708758990950136380924747359052570549594098569970632854351825950729752563502284849263730127586382522703959893392329333760927637353052250274195821469023401443841395096410231843592101426591882573405934188675124326997277775238287928403743324297705151732524641213516306585297722190780088180705070359469719869343939106529204798285957516860774384001892777525916167743272419958572055332232056095979448155082465977781482598371994798871917514767508394730447974770329967681767625495394441
'''
```

![](asserts\2024.1.6.jpg)

```
import gmpy2
from Crypto.Util.number import long_to_bytes

c = 7922547866857761459807491502654216283012776177789511549350672958101810281348402284098310147796549430689253803510994877420135537268549410652654479620858691324110367182025648788407041599943091386227543182157746202947099572389676084392706406084307657000104665696654409155006313203957292885743791715198781974205578654792123191584957665293208390453748369182333152809882312453359706147808198922916762773721726681588977103877454119043744889164529383188077499194932909643918696646876907327364751380953182517883134591810800848971719184808713694342985458103006676013451912221080252735948993692674899399826084848622145815461035
z = 32115748677623209667471622872185275070257924766015020072805267359839059393284316595882933372289732127274076434587519333300142473010344694803885168557548801202495933226215437763329280242113556524498457559562872900811602056944423967403777623306961880757613246328729616643032628964072931272085866928045973799374711846825157781056965164178505232524245809179235607571567174228822561697888645968559343608375331988097157145264357626738141646556353500994924115875748198318036296898604097000938272195903056733565880150540275369239637793975923329598716003350308259321436752579291000355560431542229699759955141152914708362494482
n = 15310745161336895413406690009324766200789179248896951942047235448901612351128459309145825547569298479821101249094161867207686537607047447968708758990950136380924747359052570549594098569970632854351825950729752563502284849263730127586382522703959893392329333760927637353052250274195821469023401443841395096410231843592101426591882573405934188675124326997277775238287928403743324297705151732524641213516306585297722190780088180705070359469719869343939106529204798285957516860774384001892777525916167743272419958572055332232056095979448155082465977781482598371994798871917514767508394730447974770329967681767625495394441
e = 65537
p = (gmpy2.iroot(z+n*2,2)[0]+gmpy2.iroot(z-n*2,2)[0])//2
q = (gmpy2.iroot(z+n*2,2)[0]-gmpy2.iroot(z-n*2,2)[0])//2

phi = (p-1)*(q-1)
d = gmpy2.invert( e , phi )
m = pow( c , d , n )
print( long_to_bytes( m ) )
```

flag:`flag{Advanced_mathematics_is_too_hard!!!}`

### 维纳攻击（Wiener's Attack）

要求：

1. $p$ 和 $q$ 相差不远
2. $d<\frac{1}{3}n^{\frac{1}{4}}$
3. $q < p  < 2 * q$

公式推导：

因为 $e d ≡ 1 mod phi$

所以 $e * d - t * phi = 1$，其中 $t$ 为整数

因为 $n = p * q  > q^2$ ，则有$ q < \sqrt{n}$

所以 $n - phi = p + q - 1 < 3 * q - 1 < 3 * q < 3\sqrt{n}$

故有$\lvert\frac{e}{n}-\frac{t}{a}\rvert$=$\lvert\frac{ed-tn}{dn}\rvert$=$\lvert\frac{1+t(phi-n)}{dn}\rvert$<$\frac{3t\sqrt{n}}{dn}$=$\frac{3t}{d\sqrt{n}}$

由于$t<a$，故 原式<$\frac{1}{dn^{\frac{1}{4}}}$<$\frac{1}{3d^2}$

综上所述，$\lvert\frac{e}{n}-\frac{t}{a}\rvert$ < $\frac{1}{3d^2}$

此时，$\frac{t}{a}$是$\frac{b}{n}$的一个收敛子

### Legendre理论

已知$\lvert\frac{(p_1-p_2)q_1q_2}{p_2}\rvert<\frac12$，则可推得$\lvert\frac{N_1}{N_2}-\frac{q_1}{q_2}\rvert<\frac{1}{2q_2^2}$

所以$\frac{q_1}{q_2}$是$\frac{N_1}{N_2}$ 的收敛子，用连分数即可求得$q_1$,$q_2$

### Easy_AES

pedding填充方式是在前面填充`b'\t\t\t\t\t\t\t\t\t'`

因而前15位永远是`\t\t\t\t\t\t\t\t\tISCTF{`

进而可以爆破得到key

已知enc，可以取它的前16位来爆破iv，进而得到flag

flag{1b106cea3fb848e7bea310c9851f15c1}

### [ISCTF2023]1zRSA

Legendre理论:

已知$\lvert\frac{(p_1-p_2)q_1q_2}{p_2}\rvert<\frac12$，则可推得$\lvert\frac{N_1}{N_2}-\frac{q_1}{q_2}\rvert<\frac{1}{2q_2^2}$

所以$\frac{q_1}{q_2}$是$\frac{N_1}{N_2}$ 连分数展开的某一项的渐进分数

```
每个连分数都可以看作由两个数列组成：一个是整数部分的数列，另一个是分数的数列。——《普林斯顿数学指南》
```

通过辗转相除法，求得连分数展开形式：具体操作是：

计算商数作为整数部分，计算余数/除数得到分数部分，取分数的倒数置于分母，进行下一轮的运行，直到可以整除为止，过程中得到的整数部分顺序排列即为连分数展开形式的数列

对于渐进分数，有 $p_i=a_ip_{i-1}+p_{i-2}$ ，$q_i=a_iq_{i-1}+q_{i-2}$ 

```
#OI-wiki上的代码
def fraction(p, q):
    a = []
    while q:
        a.append(p // q)
        p, q = q, p % q
    return a
```

```
from Crypto.Util.number import long_to_bytes
import gmpy2
c = 
N1 = 
N2 = 
e = 

a = []
p = []
q = []
def get_a( p , q ):
    a.append( p // q )
    if p % q != 0:
        get_a( q , p%q )
get_a( N1 , N2 )
p.append( a[0] ) , p.append( a[0]*a[1]+1 )
q.append( 1 ) , q.append( a[1] )
for i in range( 2 , len(a)-1 ):
    p.append( a[i]*p[i-1]+p[i-2] )
    q.append( a[i]*q[i-1]+q[i-2] )
for i in range( 0 , len(a)-1 ):
    if N1 % p[i] == 0 and p[i] != 1:
        d = gmpy2.invert( e , (p[i]-1)*(N1//p[i]-1) )
        m = pow( c , d , N1 )
        print( long_to_bytes( m ) )
```

flag:`ISCTF{6f3af9a9-2727-4d48-afb4-9ca82de893f3}`

```
references:
https://math.stackexchange.com/questions/531736/legendres-proof-continued-fractions-from-hardys-book
https://chaoli.club/index.php/2756/0
https://oi-wiki.org/math/number-theory/continued-fraction/
```

###  [PolarCTF网络安全2023冬季]base（CRYPTO）

```
import base64
import struct
raw_table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
new_table = 'GHI3KLMNJOPQRSTUb=cdefghijklmnopWXYZ/12+406789VaqrstuvwxyzABCDEF5'

cipher = 'j2rXjx8wSZjD'
flag = ""

for i in cipher:
    for j in range( len(raw_table) ):
        #print( i )
        #print( new_table[j] )
        if i == new_table[j]:
            flag += raw_table[j]
            break
print( flag )
```

base64解码得到flag

flag:`flag{666}`

### [NCTF2019]childRSA

```
from random import choice
from Crypto.Util.number import isPrime, sieve_base as primes
from flag import flag

def getPrime(bits):
    while True:
        n = 2
        while n.bit_length() < bits:
            n *= choice(primes)
        if isPrime(n + 1):
            return n + 1

e = 0x10001
m = int.from_bytes(flag.encode(), 'big')
p, q = [getPrime(2048) for _ in range(2)]
n = p * q
c = pow(m, e, n)

#n = 
#c = 
```

自行编写脚本，求得 $primes$ 都是不超过 $1e5$ 的质数，$choice()$为在列表中随机选择一个元素

观察 $p$ 和 $q$ 的生成方式，可以得到 $p-1$ 和 $q-1$ 都是 前 $10000$ 个质数里随机选择多个的乘积

设 $T = \prod primes $，故有 $T$ 是 $p-1$ 和 $q-1$ 的 整数倍，不妨设 $T=k*(p-1)$

则 $2^T-1=2^{k*(p-1)}-1 \equiv 0 (modp )$ ，故 $2^T-1 \equiv 0 (modp )$，因为$n \equiv 0 (modp )$

通过费马小定理得到 $2^T-1$ 是 $p$ 的整数倍，根据 $RSA$规则，$n$ 也是 $p$ 的整数倍，故得到 

 $gcd(2^T-1,n)=p$ 

即求得 $2^T$ 可得 $n$ 

进一步优化

因为 $2^T \% n = 2^T - k^{'}p*q $

两边同时%p，则 $2^T \% n = 2 ^ T (modp)$

```
import gmpy2
import binascii
from Crypto.Util.number import long_to_bytes
from Crypto.Util.number import isPrime, sieve_base as primes

e = 0x10001
n = 
c = 

prod = 1
for i in primes:
    prod *= i
p = gmpy2.gcd( pow(2,prd,n)-1 , n )
q = n // p
d = gmpy2.invert( e , (p-1)*(q-1) )
print( long_to_bytes(pow(c,d,n))
```

`flag{Th3r3_ar3_1ns3cure_RSA_m0duli_7hat_at_f1rst_gl4nce_appe4r_t0_be_s3cur3}`

总结：这道题给了 $p$ 和 $q$ 的生成方式，可以借此发现 $n$ 和 $\prod $ 在 $mod$ $p$ 下的关系；通过数论运算得到 $\prod$ 的等价快速运算，进而求出 $p$，得到 `flag`

### [HDCTF2019]bbbbbbrsa

```
from base64 import b64encode as b32encode
from gmpy2 import invert,gcd,iroot
from Crypto.Util.number import *
from binascii import a2b_hex,b2a_hex
import random
nbit = 128
p = getPrime(nbit)
q = getPrime(nbit)
n = p*q
phi = (p-1)*(q-1)
e = random.randint(50000,70000)
while True:
	if gcd(e,phi) == 1:
		break;
	else:
		e -= 1;
c = pow(int(b2a_hex(flag),16),e,n)
print b32encode(str(c))[::-1]

#p= 177077389675257695042507998165006460849
#n= 37421829509887796274897162249367329400988647145613325367337968063341372726061
#c= ==gMzYDNzIjMxUTNyIzNzIjMyYTM4MDM0gTMwEjNzgTM2UTN4cjNwIjN2QzM5ADMwIDNyMTO4UzM2cTM5kDN2MTOyUTO5YDM0czM3MjM
```

将 $c$ 进行字符串翻转，进行 $base64$ 解码，e数据范围很小，可以爆破

记得检查串里是否包含 `flag`，不然跑不完的

```
import gmpy2
from Crypto.Util.number import long_to_bytes

c = 2373740699529364991763589324200093466206785561836101840381622237225512234632
p = 177077389675257695042507998165006460849
n = 37421829509887796274897162249367329400988647145613325367337968063341372726061
q = n // p
phi = (p-1) * (q-1)
e = 70000
while 1:
    if gmpy2.gcd(e,phi) == 1:
        d = gmpy2.invert( e , phi )
        flag = pow( c , d , n )
        if 'flag' in str(long_to_bytes(flag)):
            print(long_to_bytes(flag))
            break
    e = e - 1
```

`flag{rs4_1s_s1mpl3!#}`

### RSA4

给了三组n和c，中国剩余定理即可求解

```
from Crypto.Util.number import long_to_bytes
import gmpy2

def crrt( c , p ):
    M = 1
    for i in p:
        M = M * i
    m = []
    for i in range(len(p)):
        m.append(M // p[i])
    x = 0
    for i in range(len(c)):
        x = x + c[i]*m[i]*gmpy2.invert(m[i],p[i])
    return x % M

n1 = ""
c1 = ""
n2 = ""
c2 = ""
n3 = ""
c3 = ""
n = [int(n1,5),int(n2,5),int(n3,5)]
c = [int(c1,5),int(c2,5),int(c3,5)]
M = crrt( c , n )
for e in range( 3 , 4 ):
    m , f = gmpy2.iroot( M , e )
    print( long_to_bytes( m ) )
```

`flag{D4mn_y0u_h4s74d_wh47_4_b100dy_b4s74rd!}`

### RSA4

```
from Crypto.Util.number import long_to_bytes
import gmpy2

def crtt( c , p ):
    M = 1
    for i in p:
        M = M * i
    m = []
    for i in range(len(p)):
        m.append(M // p[i])
    x = 0
    for i in range(len(c)):
        x = x + c[i]*m[i]*gmpy2.invert(m[i],p[i])
    return x % M

n1 =  ; c1 = 
n2 =  ; c2 = 
n3 =  ; c3 = 
e = 3

n = [n1,n2,n3]
c = [c1*2%n1,c2*2%n2,c3*2%n3]
M = crtt( c , n )*gmpy2.invert(2,n1*n2*n3)%(n1*n2*n3)
m , f = gmpy2.iroot( M , e )
result = m
print( result )
print( long_to_bytes(result) )
```

flag:`flag{D4mn_y0u_h4s74d_wh47_4_b100dy_b4s74rd!}`

### [BJDCTF2020]RSA

```
from Crypto.Util.number import long_to_bytes,bytes_to_long
import gmpy2

def gcd( a , b ):
    if a < b:
        a , b = b , a
    if b == 0:
        return a
    return gcd( b , a % b )

c1 =  ; n1 = 
t  = 
c2 =  ; n2 = 
m2 = bytes_to_long(("BJD"*32).encode())

p = gcd( n1 , n2 )
q1 = n1 // p ; q2 = n2 // p
phi = ( p - 1 ) * ( q1 - 1 )

e = 0
for i in range( 100000 ):
    if gcd( i , phi ) == 1:
        c1_ = pow( 294 , i , n1 )
        if t == c1_:
            e = i ; break
            
d = gmpy2.invert( e , phi )
print( long_to_bytes( pow( c1 , d , n1 ) ) )
```

flag:`flag{p_is_common_divisor}`

### [HDCTF2019]basic rsa

![](asserts\image-20231113083852953.png)

flag{B4by_Rs4}

### [BUUCTF]RSA5

给定很多组c和n。因为n存在不互质的数对，所以这道题就是`模不互质攻击`

```
for i in range(len(n)):
    for j in range(i+1,len(n)):
        if(gmpy2.gcd(n[i],n[j])!=1):
            print(i,j)
```

得到n5和n18存在最大公约数

所以，选择n5和n18的n进行gcd操作，即可得到p

```
import gmpy2
from Crypto.Util.number import long_to_bytes
e = 65537
n5 = 
c5 = 
n18 = 
c18 = 

p = gmpy2.gcd( n5 , n18 )
q = n5 // p

m = pow( c5 , gmpy2.invert(e,(p-1)*(q-1)) , n5 )
print( long_to_bytes( m ) )
```

flag{abdcbe5fd94e23b3de429223ab9c2fdf}

### [网鼎杯 2020 青龙组]you_raise_me_up

```
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from Crypto.Util.number import *
import random

n = 2 ** 512
m = random.randint(2, n-1) | 1
c = pow(m, bytes_to_long(flag), n)
print 'm = ' + str(m)
print 'c = ' + str(c)

# m = 391190709124527428959489662565274039318305952172936859403855079581402770986890308469084735451207885386318986881041563704825943945069343345307381099559075
# c = 6665851394203214245856789450723658632520816791621796775909766895233000234023642878786025644953797995373211308485605397024123180085924117610802485972584499
```

---

python用于解离散对数的快速方法

```
from sympy.ntheory import *
discrete_log(41,15,7)
```

即解即为 $7^x \equiv 15 \ mod \ 41$

```
from Crypto.Util.number import *
from sympy import *

m = 391190709124527428959489662565274039318305952172936859403855079581402770986890308469084735451207885386318986881041563704825943945069343345307381099559075
c = 6665851394203214245856789450723658632520816791621796775909766895233000234023642878786025644953797995373211308485605397024123180085924117610802485972584499
n = 2 ** 512

flag = discrete_log( 2**512 , c , m )
print( long_to_bytes(flag) )
```

flag:`flag{5f95ca93-1594-762d-ed0b-a9139692cb4a}	`

### [WUSTCTF2020]大数计算

```
flag等于 wctf2020{Part1-Part2-Part3-Part4} 每一Part都为数的十六进制形式（不需要0x)，并用 '-' 连接
Part1 = 2020*2019*2018* ...*3*2*1 的前8位
Part2 = 520^1314 + 2333^666 的前8位
Part3 = 宇宙终极问题的答案 x,y,z绝对值和的前8位
Part4 = 见图片附件，计算结果乘上1314
```

<img src="asserts\image-20240127120401338.png" alt="image-20240127120401338" style="zoom:33%;" />

---

```
from decimal import *

ans = Decimal(1)
for i in range( 1 , 2021 ):
    ans = ans * Decimal(i)
print( ans )
```

part1:`24d231f`

```
from decimal import *

ans1 = Decimal(1) ; ans2 = Decimal(1)
for i in range( 1 , 1314+1 ):
    ans1 = ans1 * Decimal(520)
for i in range( 1 , 666+1 ):
    ans2 = ans2 * Decimal(2333)
print( str(ans1 + ans2)[0]+str(ans1 + ans2)[2:9] )
```

part2:`403cfd3`

<img src="asserts\image-20240127115930751.png" alt="image-20240127115930751" style="zoom:50%;" />

```
print( 80538738812075974+80435758145817515+12602123297335631 )
```

part3:`108db5e`

```
def F( x ):
    return x*x
print( (F(22)-F(0)+36)*1314 )
```

part4:`a6d10`

flag:`flag{24d231f-403cfd3-108db5e-a6d10}`

### [NPUCTF2020]EzRSA

```
from gmpy2 import lcm , powmod , invert , gcd , mpz
from Crypto.Util.number import getPrime
from sympy import nextprime
from random import randint
p = getPrime(1024)
q = getPrime(1024)
n = p * q
gift = lcm(p - 1 , q - 1)
e = 54722
flag = b'NPUCTF{******************}'
m = int.from_bytes(flag , 'big')
c = powmod(m , e , n)
print('n: ' , n)
print('gift: ' , gift)
print('c: ' , c)

#n:  17083941230213489700426636484487738282426471494607098847295335339638177583685457921198569105417734668692072727759139358207667248703952436680183153327606147421932365889983347282046439156176685765143620637107347870401946946501620531665573668068349080410807996582297505889946205052879002028936125315312256470583622913646319779125559691270916064588684997382451412747432722966919513413709987353038375477178385125453567111965259721484997156799355617642131569095810304077131053588483057244340742751804935494087687363416921314041547093118565767609667033859583125275322077617576783247853718516166743858265291135353895239981121
#gift:  2135492653776686212553329560560967285303308936825887355911916917454772197960682240149821138177216833586509090969892419775958406087994054585022894165950768427741545736247918410255804894522085720642952579638418483800243368312702566458196708508543635051350999572787188236243275631609875253617015664414032058822919469443284453403064076232765024248435543326597418851751586308514540124571309152787559712950209357825576896132278045112177910266019741013995106579484868768251084453338417115483515132869594712162052362083414163954681306259137057581036657441897428432575924018950961141822554251369262248368899977337886190114104
#c:  3738960639194737957667684143565005503596276451617922474669745529299929395507971435311181578387223323429323286927370576955078618335757508161263585164126047545413028829873269342924092339298957635079736446851837414357757312525158356579607212496060244403765822636515347192211817658170822313646743520831977673861869637519843133863288550058359429455052676323196728280408508614527953057214779165450356577820378810467527006377296194102671360302059901897977339728292345132827184227155061326328585640019916328847372295754472832318258636054663091475801235050657401857262960415898483713074139212596685365780269667500271108538319
```

---

$e$ 不是质数，因为 $m^e \ mod \ n = c $ ，所以$m^{2*\frac{e}{2}} \ mod \ n = c $

使用factor分解即可得到p和q

```
from Crypto.Util.number import *
from gmpy2 import *

n = 17083941230213489700426636484487738282426471494607098847295335339638177583685457921198569105417734668692072727759139358207667248703952436680183153327606147421932365889983347282046439156176685765143620637107347870401946946501620531665573668068349080410807996582297505889946205052879002028936125315312256470583622913646319779125559691270916064588684997382451412747432722966919513413709987353038375477178385125453567111965259721484997156799355617642131569095810304077131053588483057244340742751804935494087687363416921314041547093118565767609667033859583125275322077617576783247853718516166743858265291135353895239981121
p = 161136651053130509602530659420755324119806487925813087617466818245407407797561810253722204813002837916779909309520498985459703212021249251124954613236122142746302911323565396331355397916764254680629384957057354297855676493062493901977415968666512459829211010720514167083018352796496733697235524845188512914793
q = 106021448991021391444550749375115277080844281746248845802565680557785009341952320484175568763707424932172033597514861602114171459176440279045761846695231788376075050452154924141266290931413542110639081792550648106240966552406813059396358355737185354885474455248579946190266152416149137616855791805617206153497
c = 3738960639194737957667684143565005503596276451617922474669745529299929395507971435311181578387223323429323286927370576955078618335757508161263585164126047545413028829873269342924092339298957635079736446851837414357757312525158356579607212496060244403765822636515347192211817658170822313646743520831977673861869637519843133863288550058359429455052676323196728280408508614527953057214779165450356577820378810467527006377296194102671360302059901897977339728292345132827184227155061326328585640019916328847372295754472832318258636054663091475801235050657401857262960415898483713074139212596685365780269667500271108538319
e = 54722
phi = (p-1)*(q-1)
d = gmpy2.invert( e//2 , phi )
flag = iroot(pow( c , d , n ),2)[0]
print( long_to_bytes( flag ) )
```

可能是因为有开根操作，不需要p和q也可以解密，gift就是phi

```
from Crypto.Util.number import *
from gmpy2 import *

n = 17083941230213489700426636484487738282426471494607098847295335339638177583685457921198569105417734668692072727759139358207667248703952436680183153327606147421932365889983347282046439156176685765143620637107347870401946946501620531665573668068349080410807996582297505889946205052879002028936125315312256470583622913646319779125559691270916064588684997382451412747432722966919513413709987353038375477178385125453567111965259721484997156799355617642131569095810304077131053588483057244340742751804935494087687363416921314041547093118565767609667033859583125275322077617576783247853718516166743858265291135353895239981121
phi = 2135492653776686212553329560560967285303308936825887355911916917454772197960682240149821138177216833586509090969892419775958406087994054585022894165950768427741545736247918410255804894522085720642952579638418483800243368312702566458196708508543635051350999572787188236243275631609875253617015664414032058822919469443284453403064076232765024248435543326597418851751586308514540124571309152787559712950209357825576896132278045112177910266019741013995106579484868768251084453338417115483515132869594712162052362083414163954681306259137057581036657441897428432575924018950961141822554251369262248368899977337886190114104
c = 3738960639194737957667684143565005503596276451617922474669745529299929395507971435311181578387223323429323286927370576955078618335757508161263585164126047545413028829873269342924092339298957635079736446851837414357757312525158356579607212496060244403765822636515347192211817658170822313646743520831977673861869637519843133863288550058359429455052676323196728280408508614527953057214779165450356577820378810467527006377296194102671360302059901897977339728292345132827184227155061326328585640019916328847372295754472832318258636054663091475801235050657401857262960415898483713074139212596685365780269667500271108538319
e = 54722

d = gmpy2.invert( e//2 , phi )
flag = iroot(pow( c , d , n ),2)[0]
print( long_to_bytes( flag ) )
```

flag:`flag{diff1cult_rsa_1s_e@sy}`

### [WUSTCTF2020]dp_leaking_1s_very_d@angerous

```
e = 65537
n = 156808343598578774957375696815188980682166740609302831099696492068246337198792510898818496239166339015207305102101431634283168544492984586566799996471150252382144148257236707247267506165670877506370253127695314163987084076462560095456635833650720606337852199362362120808707925913897956527780930423574343287847
c = 108542078809057774666748066235473292495343753790443966020636060807418393737258696352569345621488958094856305865603100885838672591764072157183336139243588435583104423268921439473113244493821692560960443688048994557463526099985303667243623711454841573922233051289561865599722004107134302070301237345400354257869
dp = 734763139918837027274765680404546851353356952885439663987181004382601658386317353877499122276686150509151221546249750373865024485652349719427182780275825
```

---

dp泄露的模板题

```
from Crypto.Util.number import *
import gmpy2
e = 65537
n = 156808343598578774957375696815188980682166740609302831099696492068246337198792510898818496239166339015207305102101431634283168544492984586566799996471150252382144148257236707247267506165670877506370253127695314163987084076462560095456635833650720606337852199362362120808707925913897956527780930423574343287847
c = 108542078809057774666748066235473292495343753790443966020636060807418393737258696352569345621488958094856305865603100885838672591764072157183336139243588435583104423268921439473113244493821692560960443688048994557463526099985303667243623711454841573922233051289561865599722004107134302070301237345400354257869
dp = 734763139918837027274765680404546851353356952885439663987181004382601658386317353877499122276686150509151221546249750373865024485652349719427182780275825

for i in range(1,e):
    if (dp*e-1)%i==0:
        if n%((dp*e-1)//i+1)==0:
            p=(dp*e-1)//i+1
            q=n//p
            phi=(p-1)*(q-1)
            d=gmpy2.invert(e,phi)
            print(long_to_bytes(gmpy2.powmod(c,d,n)))
            break
```

flag:`flag{dp_leaking_1s_very_d@angerous}`

### [INSHack2017]rsa16m

n（很大很大）=  ;  c =   ; e = 

---

低密度质数攻击

```
print( long_to_bytes( iroot( c , e )[0] ) )
```

flag:`flag{(I)NSA_W0uld_bE_pr0uD}`

### RSA & what

```
from Crypto.Util.number import bytes_to_long, getPrime
from random import randint
from gmpy2 import powmod

p = getPrime(2048)
q = getPrime(2048)
N = p*q
Phi = (p-1)*(q-1)
def get_enc_key(N,Phi):
    e = getPrime(N)
    if Phi % e == 0:
        return get_enc_key(N, Phi)
    else:
        return e
e1 = get_enc_key(randint(10, 12), Phi)
e2 = get_enc_key(randint(10, 12), Phi)

fr = open(r"./base64", "rb")#flag is in this file
f1 = open(r"./HUB1", "wb")
f2 = open(r"./HUB2", "wb")
base64 = fr.read(255)
f1.write("%d\n%d\n" % (N, e1))
f2.write("%d\n%d\n" % (N, e2))
while len(base64)>0:
    pt = bytes_to_long(base64)
    ct1 = powmod(pt, e1, N)
    ct2 = powmod(pt, e2, N)
    f1.write("\n%d" % ct1)
    f2.write("\n%d" % ct2)
    base64 = fr.read(255)
fr.close()
f1.close()
f2.close()
```

---

共膜攻击

```
from Crypto.Util.number import *
import base64

def exgcd( a , b ):
    if a == 0:
        return ( b , 0 , 1 )
    else:
        g , y , x = exgcd( b % a , a )  
        return ( g , x - (b//a)*y , y )

def CMA( n , e1 , e2 , c1 , c2 ):
    temp , s1 , s2 = exgcd( e1 , e2 )
    if s1 < 0:
        s1 = -s1
        c1 = inverse( c1 , n )
    elif s2 < 0:
        s2 = -s2
        c2 = inverse( c2 , n )
    m = pow( c1 , s1 , n ) * pow( c2 , s2 , n ) % n
    return m

f1 = open("HUB1") ; f2 = open("HUB2")

N , N = f1.readline() , f2.readline()
e1,e2 = f1.readline() , f2.readline()
f1.readline() ; f2.readline()
c1,c2 = f1.readline() , f2.readline()

ans = b''
cnt = 0
while( len(c1) ):
    cnt += 1
    ans += long_to_bytes( CMA(int(N),int(e1),int(e2),int(c1),int(c2)) )
    c1 , c2 = f1.readline() , f2.readline()
temp = b''
M = b''
print( ans )
for i in ans:
    k = long_to_bytes(i)
    if k == b'\n':
        M += base64.b64decode( temp )
        temp = b''
        continue
    temp += k
print( M )
```

得到密文

```
THISFLAGISHIDDEN.CANYOUFINDITOUT?DOYOUKNOWBASE64?YoungCTHINKYOUARENOTTHATFAMILIARWITHBASE64.Base64isagroupofsimilarbinary-to-textencodingschemesthatrepresentbinarydatainanASCIIstringformatbytranslatingitintoaradix-64representation.ThetermBase64originatesfromaspecificMIMEcontenttransferencoding.Theparticularsetof64characterschosentorepresentthe64place-valuesforthebasevariesbetweenimplementations.Thegeneralstrategyistochoose64charactersthatarebothmembersofasubsetcommontomostencodings,andalsoprintable.Thiscombinationleavesthedataunlikelytobemodifiedintransitthroughinformationsystems,suchasE-mail,thatweretraditionallynot8-bitclean.[1]Forexample,MIME'sBase64implementationusesA\xa8CZ,a\xa8Cz,and0\xa8C9forthefirst62values.Othervariationssharethispropertybutdifferinthesymbolschosenforthelasttwovalues;anexampleis
```

进行base64隐写解密得到

flag:`flag{7c86d8f7d6de33a87f7f9d6b005ce640}`

### [ACTF新生赛2020]crypto-aes

```
from Cryptodome.Cipher import AES
import os
import gmpy2
from flag import FLAG
from Cryptodome.Util.number import *

def main():
    key=os.urandom(2)*16
    iv=os.urandom(16)
    print(bytes_to_long(key)^bytes_to_long(iv))
    aes=AES.new(key,AES.MODE_CBC,iv)
    enc_flag = aes.encrypt(FLAG)
    print(enc_flag)
if __name__=="__main__":
    main()

"""
91144196586662942563895769614300232343026691029427747065707381728622849079757
b'\x8c-\xcd\xde\xa7\xe9\x7f.b\x8aKs\xf1\xba\xc75\xc4d\x13\x07\xac\xa4&\xd6\x91\xfe\xf3\x14\x10|\xf8p'
"""
```

---

```
from Crypto.Cipher import AES
import os
from gmpy2 import *
from Crypto.Util.number import *

xor = 91144196586662942563895769614300232343026691029427747065707381728622849079757
enc_flag = b'\x8c-\xcd\xde\xa7\xe9\x7f.b\x8aKs\xf1\xba\xc75\xc4d\x13\x07\xac\xa4&\xd6\x91\xfe\xf3\x14\x10|\xf8p'

out = long_to_bytes( xor )
key = out[:16]*2
iv = bytes_to_long(key[16:])^bytes_to_long(out[16:])
iv = long_to_bytes( iv )

aes = AES.new( key , AES.MODE_CBC , iv )
print( aes.decrypt( enc_flag ) )
```

flag:`flag{W0W_y0u_can_so1v3_AES_now!}`

### [INSHack2019]Yet Another RSA Challenge - Part 1

```
[Buy an encrypted flag, get a (almost intact) prime factor for free !](https://static.ctf.insecurity-insa.fr/595437e42ea3951e8ed4ecda16141f017f3ba36b.tar.gz)

You can find a harder version of this challenge in the Programming category.
```

```
719579745653303119025873098043848913976880838286635817351790189702008424828505522253331968992725441130409959387942238566082746772468987336980704680915524591881919460709921709513741059003955050088052599067720107149755856317364317707629467090624585752920523062378696431510814381603360130752588995217840721808871896469275562085215852034302374902524921137398710508865248881286824902780186249148613287250056380811479959269915786545911048030947364841177976623684660771594747297272818410589981294227084173316280447729440036251406684111603371364957690353449585185893322538541593242187738587675489180722498945337715511212885934126635221601469699184812336984707723198731876940991485904637481371763302337637617744175461566445514603405016576604569057507997291470369704260553992902776099599438704680775883984720946337235834374667842758010444010254965664863296455406931885650448386682827401907759661117637294838753325610213809162253020362015045242003388829769019579522792182295457962911430276020610658073659629786668639126004851910536565721128484604554703970965744790413684836096724064390486888113608024265771815004188203124405817878645103282802994701531113849607969243815078720289912255827700390198089699808626116357304202660642601149742427766381
0xDCC5A0BD3A1FC0BEB0DA1C2E8CF6B474481B7C12849B76E03C4C946724DB577D2825D6AA193DB559BC9DBABE1DDE8B5E7805E48749EF002F622F7CDBD7853B200E2A027E87E331AFCFD066ED9900F1E5F5E5196A451A6F9E329EB889D773F08E5FBF45AACB818FD186DD74626180294DCC31805A88D1B71DE5BFEF3ED01F12678D906A833A78EDCE9BDAF22BBE45C0BFB7A82AFE42C1C3B8581C83BF43DFE31BFD81527E507686956458905CC9A660604552A060109DC81D01F229A264AB67C6D7168721AB36DE769CEAFB97F238050193EC942078DDF5329A387F46253A4411A9C8BB71F9AEB11AC9623E41C14FCD2739D76E69283E57DDB11FC531B4611EE3
596380963583874022971492302071822444225514552231574984926542429117396590795270181084030717066220888052607057994262255729890598322976783889090993129161030148064314476199052180347747135088933481343974996843632511300255010825580875930722684714290535684951679115573751200980708359500292172387447570080875531002842462002727646367063816531958020271149645805755077133231395881833164790825731218786554806777097126212126561056170733032553159740167058242065879953688453169613384659653035659118823444582576657499974059388261153064772228570460351169216103620379299362366574826080703907036316546232196313193923841110510170689800892941998845140534954264505413254429240789223724066502818922164419890197058252325607667959185100118251170368909192832882776642565026481260424714348087206462283972676596101498123547647078981435969530082351104111747783346230914935599764345176602456069568419879060577771404946743580809330315332836749661503035076868102720709045692483171306425207758972682717326821412843569770615848397477633761506670219845039890098105484693890695897858251238713238301401843678654564558196040100908796513657968507381392735855990706254646471937809011610992016368630851454275478216664521360246605400986428230407975530880206404171034278692756
```

```
import subprocess
p = subprocess.check_output('openssl prime -generate -bits 2048 -hex')
q = subprocess.check_output('openssl prime -generate -bits 2048 -hex')
flag = int('INSA{REDACTED}'.encode('hex'), 16)

N = int(p,16) * int(q,16)
print N
print '0x'+p.replace('9F','FC')
print pow(flag,65537,N)
```

---

p 的16进制数被替换了一部分，通过爆破的方式获取 p 的值

```
from Crypto.Util.number import*
from gmpy2 import*
from libnum import*
N = 719579745653303119025873098043848913976880838286635817351790189702008424828505522253331968992725441130409959387942238566082746772468987336980704680915524591881919460709921709513741059003955050088052599067720107149755856317364317707629467090624585752920523062378696431510814381603360130752588995217840721808871896469275562085215852034302374902524921137398710508865248881286824902780186249148613287250056380811479959269915786545911048030947364841177976623684660771594747297272818410589981294227084173316280447729440036251406684111603371364957690353449585185893322538541593242187738587675489180722498945337715511212885934126635221601469699184812336984707723198731876940991485904637481371763302337637617744175461566445514603405016576604569057507997291470369704260553992902776099599438704680775883984720946337235834374667842758010444010254965664863296455406931885650448386682827401907759661117637294838753325610213809162253020362015045242003388829769019579522792182295457962911430276020610658073659629786668639126004851910536565721128484604554703970965744790413684836096724064390486888113608024265771815004188203124405817878645103282802994701531113849607969243815078720289912255827700390198089699808626116357304202660642601149742427766381
cipher = 596380963583874022971492302071822444225514552231574984926542429117396590795270181084030717066220888052607057994262255729890598322976783889090993129161030148064314476199052180347747135088933481343974996843632511300255010825580875930722684714290535684951679115573751200980708359500292172387447570080875531002842462002727646367063816531958020271149645805755077133231395881833164790825731218786554806777097126212126561056170733032553159740167058242065879953688453169613384659653035659118823444582576657499974059388261153064772228570460351169216103620379299362366574826080703907036316546232196313193923841110510170689800892941998845140534954264505413254429240789223724066502818922164419890197058252325607667959185100118251170368909192832882776642565026481260424714348087206462283972676596101498123547647078981435969530082351104111747783346230914935599764345176602456069568419879060577771404946743580809330315332836749661503035076868102720709045692483171306425207758972682717326821412843569770615848397477633761506670219845039890098105484693890695897858251238713238301401843678654564558196040100908796513657968507381392735855990706254646471937809011610992016368630851454275478216664521360246605400986428230407975530880206404171034278692756
plain = ['9F','FC']
for a in plain:
    for b in plain:
        for c in plain:
            for d in plain:
                p1 = '0xDCC5A0BD3A1' +a+ '0BEB0DA1C2E8CF6B474481B7C12849B76E03C4C946724DB577D2825D6AA193DB559BC9DBABE1DDE8B5E7805E48749EF002F622F7CDBD7853B200E2A027E87E331A' +b+ 'FD066ED9900F1E5F5E5196A451A6F9E329EB889D773F08E5FBF45AACB818FD186DD74626180294DCC31805A88D1B71DE5BFEF3ED01F12678D906A833A78EDCE9BDAF22BBE45C0BFB7A82AFE42C1C3B8581C83BF43DFE31BFD81527E507686956458905CC9A660604552A060109DC81D01F229A264AB67C6D7168721AB36DE769CEAFB97F238050193EC942078DDF5329A387F46253A4411A9C8BB71F9AEB11AC9623E41C14' +c+ 'D2739D76E69283E57DDB11' +d+ '531B4611EE3'
                p = int(p1,16)
                if(N%p == 0):
                    print(p)
p = 27869881035956015184979178092922248885674897320108269064145135676677416930908750101386898785101159450077433625380803555071301130739332256486285289470097290409044426739584302074834857801721989648648799253740641480496433764509396039330395579654527851232078667173592401475356727873045602595552393666889257027478385213547302885118341490346766830846876201911076530008127691612594913799272782226366932754058372641521481522494577124999360890113778202218378165756595787931498460866236502220175258385407478826827807650036729385244897815805427164434537088709092238894902485613707990645011133078730017425033369999448757627854563
q = N//p
phi = (p-1)*(q-1)
e = 65537
d = invert(e,phi)
m = pow(cipher,d,N)
print( long_to_bytes(m) )
```

flag:`flag{I_w1ll_us3_OTp_n3xT_T1M3}`

### [NPUCTF2020]认清形势，建立信心

```
from Crypto.Util.number import *
from gmpy2 import *
from secret import flag

p = getPrime(25)
e = # Hidden
q = getPrime(25)
n = p * q
m = bytes_to_long(flag.strip(b"npuctf{").strip(b"}"))

c = pow(m, e, n)
print(c)
print(pow(2, e, n))
print(pow(4, e, n))
print(pow(8, e, n))

'''
169169912654178
128509160179202
518818742414340
358553002064450
'''
```

---

$n = gcd( c_1^2-c_2 , c_1 * c_2 - c_3 )$

使用yafu对n分解

```
from Crypto.Util.number import*
from gmpy2 import*
from sympy import*

c = 169169912654178
c1 = 128509160179202
c2 = 518818742414340
c3 = 358553002064450

n = gcd(pow(c1,2)-c2,c1*c2-c3)
p = 28977097
q = 18195301
n = p*q
e = discrete_log(n,c1,2)
print(e)
phi = (p-1)*(q-1)
d = invert(e,phi)
print( long_to_bytes(pow(c,int(d),n)) )
```

flag:`flag{345y!}`

### [MRCTF2020]babyRSA

tag: RSA | 普通代码分析

```
import sympy
import random
from gmpy2 import gcd, invert
from Crypto.Util.number import getPrime, isPrime, getRandomNBitInteger, bytes_to_long, long_to_bytes
from z3 import *
flag = b"MRCTF{xxxx}"
base = 65537


def GCD(A):
    B = 1
    for i in range(1, len(A)):
        B = gcd(A[i-1], A[i])
    return B


def gen_p():
    P = [0 for i in range(17)]
    P[0] = getPrime(128)
    for i in range(1, 17):
        P[i] = sympy.nextprime(P[i-1])
    print("P_p :", P[9])
    n = 1
    for i in range(17):
        n *= P[i]
    p = getPrime(1024)
    factor = pow(p, base, n)
    print("P_factor :", factor)
    return sympy.nextprime(p)


def gen_q():
    sub_Q = getPrime(1024)
    Q_1 = getPrime(1024)
    Q_2 = getPrime(1024)
    Q = sub_Q ** Q_2 % Q_1
    print("Q_1: ", Q_1)
    print("Q_2: ", Q_2)
    print("sub_Q: ", sub_Q)
    return sympy.nextprime(Q)


if __name__ == "__main__":
    _E = base
    _P = gen_p()
    _Q = gen_q()
    assert (gcd(_E, (_P - 1) * (_Q - 1)) == 1)
    _M = bytes_to_long(flag)
    _C = pow(_M, _E, _P * _Q)
    print("Ciphertext = ", _C)
    
'''
P_p : 206027926847308612719677572554991143421
P_factor : 213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839
Q_1:  103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521
Q_2:  151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743
sub_Q:  168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651
Ciphertext =  1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832
'''
```

---

p是连续17个质数的乘积，已经给出第十个$p_9$，易得p的值

```
from gmpy2 import invert
from Crypto.Util.number import long_to_bytes
import sympy

P = [0 for i in range(17)]
P[9] = 206027926847308612719677572554991143421
for i in range( 8 , -1 , -1 ):
    P[i] = sympy.prevprime(P[i+1])
for i in range( 10 , 17 , 1 ):
    P[i] = sympy.nextprime(P[i-1])
n = 1
for i in range( 17 ):
    n *= P[i]
base = 65537
factor = 213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839

phi_n = 1
for i in range( 17 ):
    phi_n *= ( P[i] - 1 )
d = invert( base , phi_n )
p = sympy.nextprime( pow( factor , d , n ) )
```

q由三个数得到，已经给出，故易求出

```
Q_1 = 103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521
Q_2 = 151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743
sub_Q = 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651

q = sympy.nextprime( pow( sub_Q , Q_2 , Q_1 ) )

c = 1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832

phi = ( p - 1 ) * ( q - 1 )
n = p * q

e = base
d = invert( e , phi )
m = pow( c , d , n )

print( long_to_bytes( m ) )
```

flag:`MRCTF{sti11_@_b@by_qu3st10n}`

### [MRCTF2020]Easy_RSA

tag:RSA | 已知n、phi求p、q |  已知n、e*d求phi

```
import sympy
from gmpy2 import gcd, invert
from random import randint
from Crypto.Util.number import getPrime, isPrime, getRandomNBitInteger, bytes_to_long, long_to_bytes
import base64

from zlib import *
flag = b"MRCTF{XXXX}"
base = 65537

def gen_prime(N):
    A = 0
    while 1:
        A = getPrime(N)
        if A % 8 == 5:
            break
    return A

def gen_p():
    p = getPrime(1024)
    q = getPrime(1024)
    assert (p < q)
    n = p * q
    print("P_n = ", n)
    F_n = (p - 1) * (q - 1)
    print("P_F_n = ", F_n)
    factor2 = 2021 * p + 2020 * q
    if factor2 < 0:
        factor2 = (-1) * factor2
    return sympy.nextprime(factor2)


def gen_q():
    p = getPrime(1024)
    q = getPrime(1024)
    assert (p < q)
    n = p * q
    print("Q_n = ", n)
    e = getRandomNBitInteger(53)
    F_n = (p - 1) * (q - 1)
    while gcd(e, F_n) != 1:
        e = getRandomNBitInteger(53)
    d = invert(e, F_n)
    print("Q_E_D = ", e * d)
    factor2 = 2021 * p - 2020 * q
    if factor2 < 0:
        factor2 = (-1) * factor2
    return sympy.nextprime(factor2)


if __name__ == "__main__":
    _E = base
    _P = gen_p()
    _Q = gen_q()
    assert (gcd(_E, (_P - 1) * (_Q - 1)) == 1)
    _M = bytes_to_long(flag)
    _C = pow(_M, _E, _P * _Q)
    print("Ciphertext = ", _C)
'''
P_n =  14057332139537395701238463644827948204030576528558543283405966933509944444681257521108769303999679955371474546213196051386802936343092965202519504111238572269823072199039812208100301939365080328518578704076769147484922508482686658959347725753762078590928561862163337382463252361958145933210306431342748775024336556028267742021320891681762543660468484018686865891073110757394154024833552558863671537491089957038648328973790692356014778420333896705595252711514117478072828880198506187667924020260600124717243067420876363980538994101929437978668709128652587073901337310278665778299513763593234951137512120572797739181693
P_F_n =  14057332139537395701238463644827948204030576528558543283405966933509944444681257521108769303999679955371474546213196051386802936343092965202519504111238572269823072199039812208100301939365080328518578704076769147484922508482686658959347725753762078590928561862163337382463252361958145933210306431342748775024099427363967321110127562039879018616082926935567951378185280882426903064598376668106616694623540074057210432790309571018778281723710994930151635857933293394780142192586806292968028305922173313521186946635709194350912242693822450297748434301924950358561859804256788098033426537956252964976682327991427626735740
Q_n =  20714298338160449749545360743688018842877274054540852096459485283936802341271363766157976112525034004319938054034934880860956966585051684483662535780621673316774842614701726445870630109196016676725183412879870463432277629916669130494040403733295593655306104176367902352484367520262917943100467697540593925707162162616635533550262718808746254599456286578409187895171015796991910123804529825519519278388910483133813330902530160448972926096083990208243274548561238253002789474920730760001104048093295680593033327818821255300893423412192265814418546134015557579236219461780344469127987669565138930308525189944897421753947
Q_E_D =  100772079222298134586116156850742817855408127716962891929259868746672572602333918958075582671752493618259518286336122772703330183037221105058298653490794337885098499073583821832532798309513538383175233429533467348390389323225198805294950484802068148590902907221150968539067980432831310376368202773212266320112670699737501054831646286585142281419237572222713975646843555024731855688573834108711874406149540078253774349708158063055754932812675786123700768288048445326199880983717504538825498103789304873682191053050366806825802602658674268440844577955499368404019114913934477160428428662847012289516655310680119638600315228284298935201
Ciphertext =  40855937355228438525361161524441274634175356845950884889338630813182607485910094677909779126550263304194796000904384775495000943424070396334435810126536165332565417336797036611773382728344687175253081047586602838685027428292621557914514629024324794275772522013126464926990620140406412999485728750385876868115091735425577555027394033416643032644774339644654011686716639760512353355719065795222201167219831780961308225780478482467294410828543488412258764446494815238766185728454416691898859462532083437213793104823759147317613637881419787581920745151430394526712790608442960106537539121880514269830696341737507717448946962021
'''
```

---

p的生成是已知n、phi求p、q

```
pp = ( (P_n-P_F_n+1) + int(gmpy2.iroot( pow(P_n-P_F_n+1,2)-4*P_n,2)[0]) ) // 2
pq = ( (P_n-P_F_n+1) - int(gmpy2.iroot( pow(P_n-P_F_n+1,2)-4*P_n,2)[0]) ) // 2
```

q的生成是已知n、e*d求phi

$\frac{ed-1}{n} \leq k \leq \frac{ed-1}{2n}$

```
k = ( Q_E_D - 1 ) // Q_n + 1
Q_F_n = ( Q_E_D - 1 ) // k
```

完整代码

```
import gmpy2
from Crypto.Util.number import long_to_bytes
import sympy
import math

P_n =  14057332139537395701238463644827948204030576528558543283405966933509944444681257521108769303999679955371474546213196051386802936343092965202519504111238572269823072199039812208100301939365080328518578704076769147484922508482686658959347725753762078590928561862163337382463252361958145933210306431342748775024336556028267742021320891681762543660468484018686865891073110757394154024833552558863671537491089957038648328973790692356014778420333896705595252711514117478072828880198506187667924020260600124717243067420876363980538994101929437978668709128652587073901337310278665778299513763593234951137512120572797739181693
P_F_n =  14057332139537395701238463644827948204030576528558543283405966933509944444681257521108769303999679955371474546213196051386802936343092965202519504111238572269823072199039812208100301939365080328518578704076769147484922508482686658959347725753762078590928561862163337382463252361958145933210306431342748775024099427363967321110127562039879018616082926935567951378185280882426903064598376668106616694623540074057210432790309571018778281723710994930151635857933293394780142192586806292968028305922173313521186946635709194350912242693822450297748434301924950358561859804256788098033426537956252964976682327991427626735740
Q_n =  20714298338160449749545360743688018842877274054540852096459485283936802341271363766157976112525034004319938054034934880860956966585051684483662535780621673316774842614701726445870630109196016676725183412879870463432277629916669130494040403733295593655306104176367902352484367520262917943100467697540593925707162162616635533550262718808746254599456286578409187895171015796991910123804529825519519278388910483133813330902530160448972926096083990208243274548561238253002789474920730760001104048093295680593033327818821255300893423412192265814418546134015557579236219461780344469127987669565138930308525189944897421753947
Q_E_D =  100772079222298134586116156850742817855408127716962891929259868746672572602333918958075582671752493618259518286336122772703330183037221105058298653490794337885098499073583821832532798309513538383175233429533467348390389323225198805294950484802068148590902907221150968539067980432831310376368202773212266320112670699737501054831646286585142281419237572222713975646843555024731855688573834108711874406149540078253774349708158063055754932812675786123700768288048445326199880983717504538825498103789304873682191053050366806825802602658674268440844577955499368404019114913934477160428428662847012289516655310680119638600315228284298935201
Ciphertext =  40855937355228438525361161524441274634175356845950884889338630813182607485910094677909779126550263304194796000904384775495000943424070396334435810126536165332565417336797036611773382728344687175253081047586602838685027428292621557914514629024324794275772522013126464926990620140406412999485728750385876868115091735425577555027394033416643032644774339644654011686716639760512353355719065795222201167219831780961308225780478482467294410828543488412258764446494815238766185728454416691898859462532083437213793104823759147317613637881419787581920745151430394526712790608442960106537539121880514269830696341737507717448946962021

pp = ( (P_n-P_F_n+1) + int(gmpy2.iroot( pow(P_n-P_F_n+1,2)-4*P_n,2)[0]) ) // 2
pq = ( (P_n-P_F_n+1) - int(gmpy2.iroot( pow(P_n-P_F_n+1,2)-4*P_n,2)[0]) ) // 2

k = ( Q_E_D - 1 ) // Q_n + 1
Q_F_n = ( Q_E_D - 1 ) // k

qp = ( (Q_n-Q_F_n+1) + int(gmpy2.iroot( pow(Q_n-Q_F_n+1,2)-4*Q_n,2)[0]) ) // 2
qq = ( (Q_n-Q_F_n+1) - int(gmpy2.iroot( pow(Q_n-Q_F_n+1,2)-4*Q_n,2)[0]) ) // 2

if pp > pq:
    pp , pq = pq , pp
if qp > qq:
    qp , qq = qq , qp

e = 65537
p = sympy.nextprime( 2021 * pp + 2020 * pq )
q = sympy.nextprime( 2021 * qp - 2020 * qq )

c = Ciphertext
d = gmpy2.invert( e , (p-1)*(q-1) )
print( long_to_bytes( pow( c , d , p*q ) ) )
```

另一解法：使用factordb对e*d-1进行分解，得到最大的一部分作为phi

flag:`MRCTF{Ju3t_@_31mp13_que3t10n}`

### [NPUCTF2020]共 模 攻 击

tag: 共膜攻击 | 

```
#task.py
from gmpy2 import *
from Crypto.Util.number import *
from secret import flag

flag = flag.strip(b"npuctf{").strip(b"}")
m = bytes_to_long(flag)

p, q = getPrime(512), getPrime(512)
n = p * q
e1, e2 = p, q
c1, c2 = pow(m, e1, n), pow(m, e2, n)

print(n)
print(c1)
print(c2)

'''
128205304743751985889679351195836799434324346996129753896234917982647254577214018524580290192396070591032007818847697193260130051396080104704981594190602854241936777324431673564677900773992273463534717009587530152480725448774018550562603894883079711995434332008363470321069097619786793617099517770260029108149
96860654235275202217368130195089839608037558388884522737500611121271571335123981588807994043800468529002147570655597610639680977780779494880330669466389788497046710319213376228391138021976388925171307760030058456934898771589435836261317283743951614505136840364638706914424433566782044926111639955612412134198
9566853166416448316408476072940703716510748416699965603380497338943730666656667456274146023583837768495637484138572090891246105018219222267465595710692705776272469703739932909158740030049375350999465338363044226512016686534246611049299981674236577960786526527933966681954486377462298197949323271904405241585
'''
```

```
#hint.py
from gmpy2 import *
from Crypto.Util.number import *
from secret import hint

m = bytes_to_long(hint)
p = getPrime(256)
c = pow(m, 256, p)
print(p)

p, q = getPrime(256), getPrime(256)
n = p * q
e1, e2 = getPrime(32), getPrime(32)
c1, c2 = pow(c, e1, n), pow(c, e2, n)
print(n)
print(e1, c1)
print(e2, c2)

'''
107316975771284342108362954945096489708900302633734520943905283655283318535709
6807492006219935335233722232024809784434293293172317282814978688931711423939629682224374870233587969960713638310068784415474535033780772766171320461281579
2303413961 1754421169036191391717309256938035960912941109206872374826444526733030696056821731708193270151759843780894750696642659795452787547355043345348714129217723
2622163991 1613454015951555289711148366977297613624544025937559371784736059448454437652633847111272619248126613500028992813732842041018588707201458398726700828844249
'''
```

---

先解hint.txt，典型的共膜攻击

```
from gmpy2 import*
from Crypto.Util.number import*
from sympy import*

p = 107316975771284342108362954945096489708900302633734520943905283655283318535709
n = 6807492006219935335233722232024809784434293293172317282814978688931711423939629682224374870233587969960713638310068784415474535033780772766171320461281579
e1 = 2303413961 ; c1 = 1754421169036191391717309256938035960912941109206872374826444526733030696056821731708193270151759843780894750696642659795452787547355043345348714129217723
e2 = 2622163991 ; c2 = 1613454015951555289711148366977297613624544025937559371784736059448454437652633847111272619248126613500028992813732842041018588707201458398726700828844249

s = gcdext( e1 , e2 )#拓展欧几里得
c = int(powmod( c1 , s[1] , n ) * powmod( c2 , s[2] , n ) % n)

print( long_to_bytes( nthroot_mod( c , 256 , p ) ) ) #pow的逆运算（我也不知道为什么能跑，反正确实能跑，而且不慢）
```

得到hint:`m.bit_length() < 400`

```
c1=m^p mod n
c2=m^q mod n
==>n=p*q
c1=m^p mod p 
c2=m^q mod q
==>由费马小定理可知 a^p=a mod p
c1=m mod p
c2=m mod q
==>c1=m+ip c2=m+jq
c1*c2=m^2+(ip+jq)*m+ijn
c1+c2=2^m+ip+jq =>(c1+c2)*m=2*m^2+(ip+j1)*m
==>m^2-(c1+c2)*m+c1*c2=ijn=0 mod n
```

使用sage解多项式

```
#建立环
PR.<m> = PolynomialRing(Zmod(n))
#定义函数
f = m^2-(c1+c2)*m+c1*c2
#函数求解
x0 = f.small_roots(X=2^400)
print(x0)
```

![](asserts\image-20240210211529405.png)求m，m位数已知，并且c1 = m^p mod n, c2 = m^q mod n

则上限即为解

```
from Crypto.Util.number import *
print(long_to_bytes(4242839043019782000788118887372132807371568279472499477998758466224002905442227156537788110520335652385855))
```

flag:`flag{verrrrrrry_345yyyyyyy_rsaaaaaaa_righttttttt?}`

### [XNUCA2018]Warmup

tag:共膜攻击 | 流量包分析

```
from Crypto.Util.number import bytes_to_long, getPrime
from random import randint
from gmpy2 import powmod
import sys

p = getPrime(1024)
q = getPrime(1024)
N = p*q
Phi = (p-1)*(q-1)

with open("flag", 'r') as fr:
	flag = bytes_to_long(fr.read().strip())

def get_enc_key(BitLen, Phi):
    e = getPrime(BitLen)
    if Phi % e == 0:
        return get_enc_key(BitLen, Phi)
    else:
        return e

def sprint(message):
	print(message)
	sys.stdout.flush()

def communicate():
	sprint("This is a message distribute system.Please tell me your name: ")
	user = raw_input()
	bakcdoor(user)
	e = get_enc_key(randint(13, 13 + (len(user) % 4)), Phi)
	ct = powmod(flag, e, N)
	sprint("Hi %s, your N is: %d\nAnd your exponent is: %d\nLast but not least, your secret is: %d" % (user, N, e, ct))
	sprint("You will know the secret after I give you P,Q.\nSee you next time!")

if __name__ == "__main__":
	communicate()
```

和一个流量包

---

<img src="asserts\image-20240210214406625.png" alt="image-20240210214406625" style="zoom:50%;" />

找到六个有大量数字的包，提取主要数据

```
n=25118186052801903419891574512806521370646053661385577314262283167479853375867074736882903917202574957661470179148882538361560784362740207649620536746860883395110443930778132343642295247749797041449601967434690280754279589691669366595486824752597992245067619256368446164574344449914827664991591873150416287647528776014468498025993455819767004213726389160036077170973994848480739499052481386539293425983093644799960322581437734560001018025823047877932105216362961838959964371333287407071080250979421489210165485908404019927393053325809061787560294489911475978342741920115134298253806238766543518220987363050115050813263
e1=7669
c1=22917655888781915689291442748409371798632133107968171254672911561608350738343707972881819762532175014157796940212073777351362314385074785400758102594348355578275080626269137543136225022579321107199602856290254696227966436244618441350564667872879196269074433751811632437228139470723203848006803856868237706401868436321225656126491701750534688966280578771996021459620472731406728379628286405214996461164892486734170662556518782043881759918394674517409304629842710180023814702447187081112856416034885511215626693534876901484105593275741829434329109239483368867518384522955176807332437540578688867077569728548513876841471
e2=6947
c2=20494665879116666159961016125949070097530413770391893858215547229071116025581822729798313796823204861624912909030975450742122802775879194445232064367771036011021366123393917354134849911675307877324103834871288513274457941036453477034798647182106422619504345055259543675752998330786906376830335403339610903547255965127196315113331300512641046933227008101401416026809256813221480604662012101542846479052832128788279031727880750642499329041780372405567816904384164559191879422615238580181357183882111249939492668328771614509476229785062819586796660370798030562805224704497570446844131650030075004901216141893420140140568
```

发现n相同

——共膜攻击！

```
from gmpy2 import*
from Crypto.Util.number import*
from sympy import*

s = gcdext( e1 , e2 )#拓展欧几里得
c = int(powmod( c1 , s[1] , n ) * powmod( c2 , s[2] , n ) % n)

print( long_to_bytes( c ) ) #pow的逆运算（我也不知道为什么能跑，反正确实能跑，而且不慢）
```

flag嘎嘣一下子就出来了

flag:`FLAG{g00d_Luck_&_Hav3_Fun}`

### [#AFCTF2018]花开藏宝地

tag:

![](asserts\image-20240211150300214.png)

```
第80804238007977405688648566160504278593148666302626415149704905628622876270862865768337953835725801963142685182510812938072115996355782396318303927020705623120652014080032809421180400984242061592520733710243483947230962631945045134540159517488288781666622635328316972979183761952842010806304748313326215619695085380586052550443025074501971925005072999275628549710915357400946408857号藏宝图

我把我的宝藏都藏在了那里！
那个神秘的地方！
于是我把藏宝图分成了5份，交给五位贤者让他们帮我妥善保管，并且只要搜集3份就可以获得宝藏的地址。

第一位贤者将藏宝图放进时空门中说道：
“那么口令就是我的生日吧，那可是个好数字呢。”

第二位贤者将藏宝图放进宝箱，【小】声念着自己的名字锁上了宝箱。

第三位贤者将藏宝图施上咒语丢进大海：“只要【大】声喊出那句咒语就可以把水驱逐！”

第四位贤者找了个破锁锁上了宝箱，狡黠地笑着：“谁知道它是坏的呢？”

第五位贤者给藏宝图裹上了隐身衣，放入了一个匣子里

据说，只有拥有【智慧】与【力量】就可以获得宝藏了呢！~
你是这样的勇者吗？
```

---

除了第五个压缩包，剩下四个压缩包被加密了

点开txt，发现有一串很奇怪的数字

这是什么，好奇怪，转一下

```
from sympy import*

txt = 80804238007977405688648566160504278593148666302626415149704905628622876270862865768337953835725801963142685182510812938072115996355782396318303927020705623120652014080032809421180400984242061592520733710243483947230962631945045134540159517488288781666622635328316972979183761952842010806304748313326215619695085380586052550443025074501971925005072999275628549710915357400946408857

print( long_to_bytes( txt ) )
```

得到一个像是flag的东西

```
b"A treasure map is a map that marks the location of buried treasure, a lost mine, a valuable secret or a hidden locale.So flag is afctf{1sn't_s0_int3Resting}\x99"
```

交一下？对了？？？

那压缩包·······

### RSA & what

```
from Crypto.Util.number import bytes_to_long, getPrime
from random import randint
from gmpy2 import powmod

p = getPrime(2048)
q = getPrime(2048)
N = p*q
Phi = (p-1)*(q-1)
def get_enc_key(N,Phi):
    e = getPrime(N)
    if Phi % e == 0:
        return get_enc_key(N, Phi)
    else:
        return e
e1 = get_enc_key(randint(10, 12), Phi)
e2 = get_enc_key(randint(10, 12), Phi)

fr = open(r"./base64", "rb")#flag is in this file
f1 = open(r"./HUB1", "wb")
f2 = open(r"./HUB2", "wb")
base64 = fr.read(255)
f1.write("%d\n%d\n" % (N, e1))
f2.write("%d\n%d\n" % (N, e2))
while len(base64)>0:
    pt = bytes_to_long(base64)
    ct1 = powmod(pt, e1, N)
    ct2 = powmod(pt, e2, N)
    f1.write("\n%d" % ct1)
    f2.write("\n%d" % ct2)
    base64 = fr.read(255)
fr.close()
f1.close()
f2.close()
```

---

共膜攻击

```
from Crypto.Util.number import *
import base64

def exgcd( a , b ):
    if a == 0:
        return ( b , 0 , 1 )
    else:
        g , y , x = exgcd( b % a , a )  
        return ( g , x - (b//a)*y , y )

def CMA( n , e1 , e2 , c1 , c2 ):
    temp , s1 , s2 = exgcd( e1 , e2 )
    if s1 < 0:
        s1 = -s1
        c1 = inverse( c1 , n )
    elif s2 < 0:
        s2 = -s2
        c2 = inverse( c2 , n )
    m = pow( c1 , s1 , n ) * pow( c2 , s2 , n ) % n
    return m

f1 = open("HUB1") ; f2 = open("HUB2")

N , N = f1.readline() , f2.readline()
e1,e2 = f1.readline() , f2.readline()
f1.readline() ; f2.readline()
c1,c2 = f1.readline() , f2.readline()

ans = b''
cnt = 0
while( len(c1) ):
    cnt += 1
    ans += long_to_bytes( CMA(int(N),int(e1),int(e2),int(c1),int(c2)) )
    c1 , c2 = f1.readline() , f2.readline()
temp = b''
M = b''
print( ans )
for i in ans:
    k = long_to_bytes(i)
    if k == b'\n':
        M += base64.b64decode( temp )
        temp = b''
        continue
    temp += k
print( M )
```

得到密文

```
THISFLAGISHIDDEN.CANYOUFINDITOUT?DOYOUKNOWBASE64?YoungCTHINKYOUARENOTTHATFAMILIARWITHBASE64.Base64isagroupofsimilarbinary-to-textencodingschemesthatrepresentbinarydatainanASCIIstringformatbytranslatingitintoaradix-64representation.ThetermBase64originatesfromaspecificMIMEcontenttransferencoding.Theparticularsetof64characterschosentorepresentthe64place-valuesforthebasevariesbetweenimplementations.Thegeneralstrategyistochoose64charactersthatarebothmembersofasubsetcommontomostencodings,andalsoprintable.Thiscombinationleavesthedataunlikelytobemodifiedintransitthroughinformationsystems,suchasE-mail,thatweretraditionallynot8-bitclean.[1]Forexample,MIME'sBase64implementationusesA\xa8CZ,a\xa8Cz,and0\xa8C9forthefirst62values.Othervariationssharethispropertybutdifferinthesymbolschosenforthelasttwovalues;anexampleis
```

进行base64隐写解密得到

flag:`flag{7c86d8f7d6de33a87f7f9d6b005ce640}`
